C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MCP_CORE
OBJECT MODULE PLACED IN .\src\MCP_Core.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\A92862\
                    -SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\MCP_Core.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) 
                    -FLOATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB
                    -1_BLDC_PORT\inc;C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\inc\config;C:/SiliconLabs/SimplicityStud
                    -io/v4/developer/sdks/8051/v4.1.7//kits/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v4/developer/s
                    -dks/8051/v4.1.7//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/common/bsp;C:/Silic
                    -onLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/EFM8BB1_LCK/config;C:/SiliconLabs/SimplicityStudio/v4/develo
                    -per/sdks/8051/v4.1.7//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM
                    -8BB1/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB1/peripheral_driver/inc) PRINT(.\sr
                    -c\MCP_Core.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\MCP_Core.OBJ)

line level    source

   1          //------------------------------------------------------------------------------
   2          // MCP_Core.c
   3          //------------------------------------------------------------------------------
   4          // Copyright (C) 2013, Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Description:
   8          //
   9          // This file implements core of MCP. It receives commands from controller over
  10          // UART interface, parse and process them. Most of commands read or write MCP
  11          // registers. It also sends response and/or MCP register values to controller
  12          // over UART interface. It also support some non-register commands like mode
  13          // switching commands. MCP can operate in two modes: Text Mode or Binary Mode.
  14          // Default mode is Text Mode. It can switch from one mode to other. Each mode
  15          // can process a set of commands. Unsupported commands are responded with ERROR.
  16          //
  17          // Release 0.0 - April 12, 2013 mufayyuz
  18          //    -Initial Revision.
  19          //
  20          
  21          //------------------------------------------------------------------------------
  22          // INCLUDES
  23          //------------------------------------------------------------------------------
  24          #include "bldcdk.h"
  25          
  26          #ifdef BUILD_FOR_PROTOCOL
  27          
  28          //#define PRINT_IN_HEX
  29          #define PRINT_IN_DEC
  30          
  31          //------------------------------------------------------------------------------
  32          // Constants
  33          //------------------------------------------------------------------------------
  34          #define MCP_TEXT_MODE   0
  35          #define MCP_BINARY_MODE 1
  36          
  37          #define MCP_DEBUG_BUF_SIZE 32
  38          
  39          #define MCP_STATUS_BUF_SIZE 16
  40          
  41          #define MCP_COMMAND_SIZE 20
  42          #define MCP_COMMAND_TYPE_INDEX 0
  43          #define MCP_COMMAND_ADDR_INDEX 1
  44          #define MCP_COMMAND_DATA_INDEX 4
  45          
  46          //------------------------------------------------------------------------------
  47          // DATA TYPES
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 2   

  48          //------------------------------------------------------------------------------
  49          typedef enum _cmd
  50          {
  51              MCP_COMMAND_NULL,
  52              MCP_COMMAND_RESET,
  53              MCP_COMMAND_TEXT_MODE,
  54              MCP_COMMAND_BIN_MODE,
  55              MCP_COMMAND_WRITE_REG,
  56              MCP_COMMAND_READ_REG,
  57              MCP_COMMAND_ENABLE_UPDATE,
  58              MCP_COMMAND_TUNE_PID,
  59              /*TODO: add more if needed*/
  60              MCP_COMMAND_INVALID,
  61          } mcp_command_t;
  62          
  63          //------------------------------------------------------------------------------
  64          // Local Variables
  65          //------------------------------------------------------------------------------
  66          static U8 MCP_mode;
  67          static mcp_command_t MCP_cmd_type;
  68          
  69          #ifdef BUILD_FOR_DEBUG
              #ifdef PRINT_IN_HEX
              static U8 code MCP_aschextable[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                                  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
              #endif
              #endif
  75          
  76          //------------------------------------------------------------------------------
  77          // MCP_Command[] has a capacity of only one command. Any data received during
  78          // processing of last received command will be ignored.
  79          //------------------------------------------------------------------------------
  80          static U8 SEG_IDATA MCP_command[MCP_COMMAND_SIZE];
  81          static U8 SEG_IDATA *MCP_command_ptr;
  82          static U8 SEG_IDATA *MCP_command_ptr_2;
  83          
  84          // Buffer used for ASCII <-> number conversions
  85          static U8 SEG_IDATA MCP_numcnvbuf[10];
  86          
  87          #define MCP_INIT_CMDPTR()   do { MCP_command_ptr = &MCP_command[0]; } while (0)
  88          
  89          #ifdef BUILD_FOR_DEBUG
              static U8 MCP_debug_head;
              static U8 MCP_debug_tail;
              static U8 SEG_XDATA MCP_debug_buffer[MCP_DEBUG_BUF_SIZE];
              
              #define MCP_debug_add(b)   do {     \
                  *(U8 SEG_XDATA *)MCP_debug_tail = (b);  \
              } while (0)
              
              #define MCP_debug_get()   *(U8 SEG_XDATA *)MCP_debug_head
              
              #define MCP_debug_INCPTR(p)    do { \
                      (p)++;  \
                      if ((p) == (U8)&MCP_debug_buffer[MCP_DEBUG_BUF_SIZE])   \
                          (p) = (U8)&MCP_debug_buffer[0];    \
              } while (0)
              #endif
 106          
 107          static U8 MCP_status_head;
 108          static U8 MCP_status_tail;
 109          static U8 SEG_XDATA MCP_status_buffer[MCP_STATUS_BUF_SIZE];
 110          
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 3   

 111          #define MCP_status_add(b)   do {    \
 112              *(U8 SEG_XDATA *)MCP_status_tail = (b); \
 113          } while (0)
 114          
 115          #define MCP_status_get()   *(U8 SEG_XDATA *)MCP_status_head
 116          
 117          #define MCP_status_INCPTR(p)    do {    \
 118                  (p)++;  \
 119                  if ((p) == (U8)&MCP_status_buffer[MCP_STATUS_BUF_SIZE]) \
 120                      (p) = (U8)&MCP_status_buffer[0];    \
 121          } while (0)
 122          
 123          static bit MCP_txqueue_lock;
 124          
 125          static bit MCP_temp1;
 126          static bit MCP_reset_cmd;
 127          static U8 SEG_DATA MCP_temp8_1;
 128          static U8 SEG_DATA MCP_temp8_2;
 129          static U16 SEG_DATA MCP_temp16_1;
 130          static U16 SEG_DATA MCP_temp16_2;
 131          
 132          struct pt SEG_XDATA mcp;
 133          struct pt SEG_XDATA mcp_tune;
 134          struct pt SEG_XDATA mcp_status;
 135          
 136          #ifdef BUILD_FOR_DEBUG
              struct pt SEG_XDATA mcp_debug;
              #endif
 139          
 140          //Pointers to call back functions
 141          U8 (* MCP_tune_callback) (U16, U16);
 142          bit (* MCP_reset_callback) (void);
 143          
 144          //------------------------------------------------------------------------------
 145          // Local Functions Prototypes
 146          //------------------------------------------------------------------------------
 147          static bit MCP_receive_command (void);
 148          static bit MCP_get_register_address(void);
 149          static bit MCP_process_command (void);
 150          static void MCP_update_status (void);
 151          static void MCP_send_ascii_value (U16);
 152          static void MCP_init_commandbuf(void);
 153          static U8 MCP_dec_to_ascnumbuf(U32 value);
 154          
 155          static U8 MCP_command_task(void);
 156          static U8 MCP_status_update_task(void);
 157          
 158          #ifdef BUILD_FOR_DEBUG
              static U8 MCP_print_task(void);
              #endif
 161          
 162          //------------------------------------------------------------------------------
 163          // APIs
 164          //------------------------------------------------------------------------------
 165          
 166          //------------------------------------------------------------------------------
 167          // MCP_init:
 168          // void MCP_init (void)
 169          //
 170          // Return Value:
 171          //     None
 172          //
 173          // Parameters:
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 4   

 174          //     None
 175          //
 176          // Description:
 177          //     This function initializes MCP core and MCP registers. It should be called
 178          //     by application at startup.
 179          //------------------------------------------------------------------------------
 180          void MCP_init (void)
 181          {
 182   1          MCP_reset_cmd = 0;
 183   1          MCP_mode = MCP_TEXT_MODE;
 184   1          MCP_cmd_type = MCP_COMMAND_INVALID;
 185   1      
 186   1          MCP_init_commandbuf();
 187   1          MCP_command_ptr_2 = MCP_command_ptr;
 188   1      
 189   1      #ifdef BUILD_FOR_DEBUG
                  MCP_debug_head = (U8)&MCP_debug_buffer[0];
                  MCP_debug_tail = MCP_debug_head;
              #endif
 193   1      
 194   1          MCP_status_head = (U8)&MCP_status_buffer[0];
 195   1          MCP_status_tail = MCP_status_head;
 196   1      
 197   1          MCP_txqueue_lock = 0;
 198   1      
 199   1          PT_INIT(&mcp);
 200   1      
 201   1      #ifdef BUILD_FOR_DEBUG
                  PT_INIT(&mcp_debug);
              #endif
 204   1      
 205   1          PT_INIT(&mcp_status);
 206   1      
 207   1          MCP_init_registers();
 208   1      
 209   1      }
 210          
 211          //------------------------------------------------------------------------------
 212          // MCP_task:
 213          // void MCP_task (void)
 214          //
 215          // Return Value:
 216          //     None
 217          //
 218          // Parameters:
 219          //     None
 220          //
 221          // Description:
 222          //     It is supposed to run forever. It should be called repeatedly by
 223          //     application at regular interval. It runs different threads.
 224          //------------------------------------------------------------------------------
 225          void MCP_task (void)
 226          {
 227   1          MCP_command_task();
 228   1          MCP_status_update_task();
 229   1      
 230   1      #ifdef BUILD_FOR_DEBUG
                  MCP_print_task();
              #endif
 233   1      }
 234          
 235          //------------------------------------------------------------------------------
 236          // MCP Debug Print
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 5   

 237          // void MCP_debug_Print (const U8 *str, U32 value)
 238          //
 239          // Return Value:
 240          //     None
 241          //
 242          // Parameters:
 243          //     Debug string/message to be printed.
 244          //
 245          // Description:
 246          //     This function can be used by application to print simple debug messages.
 247          //     It does not support printing values. Each message is started with 0xFF to
 248          //     indicate that it is debug message so that terminal program/console can
 249          //     distinguish it from MCP responses.
 250          //
 251          //------------------------------------------------------------------------------
 252          #ifdef BUILD_FOR_DEBUG
              
              void MCP_debug_print (const U8 * data str, U32 value)
              {
                  U8 idx;
              
                  //This indicates that following string as a debug message
                  MCP_debug_add(0xFF);
                  MCP_debug_INCPTR(MCP_debug_tail);
              
                  while (0 != *str)
                  {
                      if ('%' == *str)
                      {
              
              #ifdef PRINT_IN_HEX
                          if ('x' == *(str + 1))
                          {
                              str += 2;
              
                              MCP_debug_add('0');
                              MCP_debug_INCPTR(MCP_debug_tail);
                              MCP_debug_add('x');
                              MCP_debug_INCPTR(MCP_debug_tail);
              
                              // Convert it to hex number format
                              // in reverse byte order
                              for (idx = 0; idx < 10; idx++)
                              {
                                  MCP_numcnvbuf[idx] = value & 0x0f;
                                  value >>= 4;
                                  if (0 == value)
                                  {
                                      break;
                                  }
                              }
              
                              for (; idx != 0xff; idx--)
                              {
                                  MCP_debug_add(MCP_aschextable[MCP_numcnvbuf[idx]]);
                                  MCP_debug_INCPTR(MCP_debug_tail);
                              }
                              continue;   // Skip incrementing the index
                          }
                          else
              #endif //PRINT_IN_HEX
              
              #ifdef PRINT_IN_DEC
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 6   

                          if ('d' == *(str + 1))
                          {
                              str += 2;
              
                              // Convert it to hex number format
                              // in reverse byte order
                              idx = MCP_dec_to_ascnumbuf(value);
              
                              for (; idx != 0xff; idx--)
                              {
                                  MCP_debug_add(MCP_numcnvbuf[idx]);
                                  MCP_debug_INCPTR(MCP_debug_tail);
                              }
                              continue;   // Skip incrementing the index
                          }
                          else
              #endif //PRINT_IN_DEC
                          {
                                  str += 2;
                          }
                      }
                      else
                      {
                          MCP_debug_add(*str);
                          str++;
                      }
              
                      MCP_debug_INCPTR(MCP_debug_tail);
                  }
              }
              #endif
 331          
 332          //------------------------------------------------------------------------------
 333          // Local Functions
 334          //------------------------------------------------------------------------------
 335          
 336          //------------------------------------------------------------------------------
 337          // MCP_dec_to_ascnumbuf:
 338          // static U8 MCP_dec_to_ascnumbuf(U32 value)
 339          //
 340          // Return Value:
 341          //     index into last used byte in MCP_numcnvbuf
 342          //
 343          // Parameters:
 344          //     value - value to be converted to ASCII decimal number
 345          //
 346          // Description:
 347          //     This function converts a decimal value into an ASCII string in reverse
 348          //     order and stores it in MCP_numcnvbuf[]. The caller can read it downwards
 349          //     using returned index.
 350          //
 351          //------------------------------------------------------------------------------
 352          static U8 MCP_dec_to_ascnumbuf(U32 value)
 353          {
 354   1          U8 idx;
 355   1          U8 bval;
 356   1      
 357   1          // Convert it to hex number format in reverse byte order
 358   1          for (idx = 0; idx < 10; idx++)
 359   1          {
 360   2              bval = value % 10;
 361   2              MCP_numcnvbuf[idx] = bval + '0';
 362   2              value /= 10;
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 7   

 363   2              if (0 == value)
 364   2              {
 365   3                  break;
 366   3              }
 367   2          }
 368   1      
 369   1          return idx;
 370   1      }
 371          
 372          //------------------------------------------------------------------------------
 373          // MCP_init_commandbuf:
 374          // static void MCP_init_commandbuf (void)
 375          //
 376          // Return Value:
 377          //     None
 378          //
 379          // Parameters:
 380          //     None
 381          //
 382          // Description:
 383          //     This function initializes MCP command buffer to zero.  It clears the old
 384          //     command and allows new commands to be read and processed. It should be
 385          //     called when previous command is processed completely.
 386          //------------------------------------------------------------------------------
 387          static void MCP_init_commandbuf(void)
 388          {
 389   1          for (MCP_command_ptr = &MCP_command[0];
 390   1               MCP_command_ptr != &MCP_command[MCP_COMMAND_SIZE]; ++MCP_command_ptr)
 391   1          {
 392   2              *MCP_command_ptr = 0;
 393   2          }
 394   1      
 395   1          MCP_command_ptr = &MCP_command[0];
 396   1      }
 397          
 398          //------------------------------------------------------------------------------
 399          // MCP_command_task:
 400          // void MCP_command_task (void)
 401          //
 402          // Return Value:
 403          //     Proto-thread state
 404          //         0: PT_WAITING
 405          //         1: PT_YIELDED
 406          //         2: PT_EXITED
 407          //         3: PT_ENDED
 408          //
 409          // Parameters:
 410          //     None
 411          //
 412          // Description:
 413          //     This is the command handling thread. It is supposed to run forever. It is
 414          //     called by MCP_task() which is run repeatedly by application at regular
 415          //     interval. It waits for command. Once complete command is received, it
 416          //     processes it and sends response if required. Command processing is mode
 417          //     dependent.
 418          //------------------------------------------------------------------------------
 419          static U8 MCP_command_task (void)
 420          {
 421   1          PT_BEGIN(&mcp);
 422   3      
 423   3          while (1)
 424   3          {
 425   4              PT_WAIT_UNTIL(&mcp, (0 == MCP_receive_command()));
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 8   

 426   4      
 427   4              if (MCP_BINARY_MODE == MCP_mode)
 428   4              {
 429   5                  MCP_INIT_CMDPTR();
 430   5      
 431   5                  //Only one command is accepted in BIN mode - switch to TEXT mode
 432   5                  if (MCP_COMMAND_TEXT_MODE == MCP_cmd_type)
 433   5                  {
 434   6                      MCP_process_command();
 435   6                  }
 436   5              }
 437   4              else if (MCP_TEXT_MODE == MCP_mode)
 438   4              {
 439   5                  //Perform command specific action
 440   5                  if (0 == MCP_process_command())
 441   5                  {
 442   6      #ifdef FEATURE_PID_TUNE_FUNCTION
                              //TUNE PID has a special handling. Response is not sent immediately.
                              if (MCP_COMMAND_TUNE_PID == MCP_cmd_type)
                              {
                                  //Wait here until call-back function returns 0.
                                  PT_SPAWN(&mcp, &mcp_tune, MCP_tune_callback(MCP_temp16_1,
                                                                               MCP_temp16_2));
              
                                  MCP_INIT_CMDPTR();
                                  MCP_temp16_1 =
                                            MCP_get_16bit_register(MCP_REG_PROPORTIONAL_GAIN);
                                  MCP_send_ascii_value(MCP_temp16_1);
                                  *MCP_command_ptr++ = ',';
              
                                  MCP_temp16_1 =
                                                MCP_get_16bit_register(MCP_REG_INTEGRAL_GAIN);
                                  MCP_send_ascii_value(MCP_temp16_1);
                                  *MCP_command_ptr++ = '\n';
                              }
              #endif
 462   6                      //If command is switch to BIN mode, do not send "OK\n"
 463   6                      if (MCP_COMMAND_BIN_MODE != MCP_cmd_type)
 464   6                      {
 465   7                          *MCP_command_ptr++ = 'O';
 466   7                          *MCP_command_ptr++ = 'K';
 467   7                          *MCP_command_ptr++ = '\n';
 468   7                      }
 469   6                  }
 470   5                  else
 471   5                  {
 472   6                      *MCP_command_ptr++ = 'E';
 473   6                      *MCP_command_ptr++ = 'R';
 474   6                      *MCP_command_ptr++ = 'R';
 475   6                      *MCP_command_ptr++ = 'O';
 476   6                      *MCP_command_ptr++ = 'R';
 477   6                      *MCP_command_ptr++ = '\n';
 478   6                  }
 479   5              }
 480   4      
 481   4              //Command is processed and response is prepared. Now send the response.
 482   4              if (MCP_COMMAND_TEXT_MODE != MCP_cmd_type)
 483   4              {
 484   5                  MCP_command_ptr_2 = &MCP_command[0];
 485   5      
 486   5                  PT_WAIT_UNTIL(&mcp, (0 == MCP_txqueue_lock));
 487   5                  MCP_txqueue_lock = 1;   // Lock the UART tx queue
 488   5      
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 9   

 489   5                  while (MCP_command_ptr_2 != MCP_command_ptr)
 490   5                  {
 491   6                      PT_WAIT_UNTIL(&mcp, (1 < UART_get_tx_buffer_free_bytes()));
 492   6                      UART_send_byte(*MCP_command_ptr_2);
 493   6                      MCP_command_ptr_2++;
 494   6                  }
 495   5                  MCP_txqueue_lock = 0;
 496   5              }
 497   4      
 498   4              //Last command was RST command
 499   4              if (1 == MCP_reset_cmd)
 500   4              {
 501   5                  PT_WAIT_UNTIL(&mcp, (UART_BUF_SIZE == UART_get_tx_buffer_free_bytes()));
 502   5      
 503   5                  MCP_temp8_1 = 0;
 504   5                  while (254 > MCP_temp8_1)
 505   5                  {
 506   6                      MCP_temp8_1++;
 507   6                  }
 508   5      
 509   5                  RSTSRC = 0x10;
 510   5                  while(1);
 511   5              }
 512   4      
 513   4              //Command has been processed. Clear last command and accept new.
 514   4              MCP_init_commandbuf();
 515   4      
 516   4              //Allow next command to be processed
 517   4              MCP_cmd_type = MCP_COMMAND_INVALID;
 518   4          }
 519   3      
 520   3          PT_END(&mcp);
 521   1      }
 522          
 523          
 524          //------------------------------------------------------------------------------
 525          // MCP_status_update_task:
 526          // static U8 MCP_status_update_task (void)
 527          //
 528          // Return Value:
 529          //     Proto-thread state
 530          //         0: PT_WAITING
 531          //         1: PT_YIELDED
 532          //         2: PT_EXITED
 533          //         3: PT_ENDED
 534          //
 535          // Parameters:
 536          //     None
 537          //
 538          // Description:
 539          //     This is the status update thread. It is supposed to run forever. It is
 540          //     called by MCP_task() which is run repeatedly by application at regular
 541          //     interval. In binary mode, it prepares data to be sent during status
 542          //     update process. Then it sends status data if any.
 543          //------------------------------------------------------------------------------
 544          static U8 MCP_status_update_task(void)
 545          {
 546   1          if (MCP_BINARY_MODE == MCP_mode)
 547   1          {
 548   2              MCP_update_status();
 549   2          }
 550   1      
 551   1          PT_BEGIN(&mcp_status);
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 10  

 552   3      
 553   3          while (1)
 554   3          {
 555   4              PT_WAIT_UNTIL(&mcp_status, (MCP_status_tail != MCP_status_head) && (0 == MCP_txqueue_lock));
 556   4      
 557   4              MCP_txqueue_lock = 1;    // Lock the UART tx queue
 558   4              while (MCP_status_tail != MCP_status_head)
 559   4              {
 560   5                  PT_WAIT_UNTIL(&mcp_status, (1 < UART_get_tx_buffer_free_bytes()));
 561   5                  UART_send_byte(MCP_status_get());
 562   5                  MCP_status_INCPTR(MCP_status_head);
 563   5              }
 564   4              MCP_txqueue_lock = 0;
 565   4          }
 566   3          PT_END(&mcp_status);
 567   1      }
 568          
 569          #ifdef BUILD_FOR_DEBUG
              //------------------------------------------------------------------------------
              // MCP_print_task:
              // static void MCP_print_task (void)
              //
              // Return Value:
              //     Proto-thread state
              //         0: PT_WAITING
              //         1: PT_YIELDED
              //         2: PT_EXITED
              //         3: PT_ENDED
              //
              // Parameters:
              //     None
              //
              // Description:
              //     This is the printing thread. It is supposed to run forever. It is called
              //     by MCP_task() which is run repeatedly by application at regular interval.
              //     It waits until there is something to print.
              //------------------------------------------------------------------------------
              static U8 MCP_print_task(void)
              {
                  PT_BEGIN(&mcp_debug);
              
                  while (1)
                  {
                      PT_WAIT_UNTIL(&mcp_debug, (MCP_debug_tail != MCP_debug_head) &&
                              (0 == MCP_txqueue_lock));
              
                      MCP_txqueue_lock = 1;   // Lock the UART tx queue
                      while (MCP_debug_tail != MCP_debug_head)
                      {
                          PT_WAIT_UNTIL(&mcp_debug, (1 < UART_get_tx_buffer_free_bytes()));
                          UART_send_byte(MCP_debug_get());
                          MCP_debug_INCPTR(MCP_debug_head);
                      }
                      MCP_txqueue_lock = 0;
                  }
              
                  PT_END(&mcp_debug);
                  return PT_ENDED;
              }
              
              #endif //BUILD_FOR_DEBUG
 613          
 614          //------------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 11  

 615          // MCP_receive_command
 616          // static bit MCP_receive_command (void)
 617          //
 618          // Return Value:
 619          //     0: Command received completely
 620          //     1: Command not received
 621          //
 622          // Parameters:
 623          //     None
 624          //
 625          // Description:
 626          //     It is uses UART API to get received byte to accumulate full command.
 627          //     Command is considered completely received if '\n' is received (because
 628          //     most of commands are terminated by '\n'). However, mode switch commands
 629          //     are not terminated by '\n' and therefore handled separately.
 630          //
 631          //------------------------------------------------------------------------------
 632          static bit MCP_receive_command (void)
 633          {
 634   1          if (UART_SUCCESS == UART_receive_byte(&MCP_temp8_1))
 635   1          {
 636   2              *MCP_command_ptr = MCP_temp8_1;
 637   2      
 638   2              if (MCP_command_ptr == &MCP_command[MCP_COMMAND_TYPE_INDEX + 2])
 639   2              {
 640   3                  if (('+' == MCP_command[MCP_COMMAND_TYPE_INDEX + 0]) &&
 641   3                      ('+' == MCP_command[MCP_COMMAND_TYPE_INDEX + 1]) &&
 642   3                      ('+' == MCP_command[MCP_COMMAND_TYPE_INDEX + 2]))
 643   3                  {
 644   4                      MCP_cmd_type = MCP_COMMAND_TEXT_MODE;
 645   4                      return 0;
 646   4                  }
 647   3                  else if (('^' == MCP_command[MCP_COMMAND_TYPE_INDEX + 0]) &&
 648   3                           ('^' == MCP_command[MCP_COMMAND_TYPE_INDEX + 1]) &&
 649   3                           ('^' == MCP_command[MCP_COMMAND_TYPE_INDEX + 2]))
 650   3                  {
 651   4                      MCP_cmd_type = MCP_COMMAND_BIN_MODE;
 652   4                      return 0;
 653   4                  }
 654   3              }
 655   2              else if ('\n' == *MCP_command_ptr)
 656   2              {
 657   3                  return 0;
 658   3              }
 659   2      
 660   2              MCP_command_ptr++;
 661   2              // something wrong...(maybe wrong uart baud rate in PC side)
 662   2              if( MCP_command_ptr == &MCP_command[MCP_COMMAND_SIZE])
 663   2              {
 664   3                  // stop motor first.
 665   3                  MCP_reset_callback();
 666   3                  RSTSRC = 0x10;
 667   3                  while(1);
 668   3              }
 669   2          }
 670   1          return 1;
 671   1      }
 672          
 673          //------------------------------------------------------------------------------
 674          // MCP_hex_to_dec
 675          // static U8 MCP_hex_to_dec (U8 aschex)
 676          //
 677          // Return Value:
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 12  

 678          //     0x00 to 0x0F: If input is a valid ASCII Hex number.
 679          //     0xFF: If input is not a valid ASCII Hex number.
 680          //
 681          // Parameters:
 682          //     Ascii Hex digit.
 683          //
 684          // Description:
 685          //     It converts ACSII Hex digit to corresponding decimal value. It checks if
 686          //     input is a valid ASCII Hex digit or not. If valid, it returns a valid
 687          //     number between 0x00 and 0x0F otherwise it returns 0xFF.
 688          //     Valid ASCII hex digits are 0, 1, ..,9, A, B, ..., F, a, b, ..., f.
 689          //------------------------------------------------------------------------------
 690          static U8 MCP_hex_to_dec(U8 aschex)
 691          {
 692   1          if (('0' <= aschex) && ('9' >= aschex))
 693   1          {
 694   2              return aschex - '0';
 695   2          }
 696   1          else if (('a' <= aschex) && ('f' >= aschex))
 697   1          {
 698   2              return (aschex - 'a' + 10);
 699   2          }
 700   1          else if (('A' <= aschex) && ('F' >= aschex))
 701   1          {
 702   2              return (aschex - 'A' + 10);
 703   2          }
 704   1      
 705   1          return 0xFF;
 706   1      }
 707          
 708          //------------------------------------------------------------------------------
 709          // MCP_get_register_address
 710          // static bit MCP_get_register_address (void)
 711          //
 712          // Return Value:
 713          //     0: If address field in the command represents a valid Hex value
 714          //     1: If address field in the command does not represent valid Hex value
 715          //
 716          // Parameters:
 717          //     None
 718          //
 719          // Description:
 720          //     It checks both ASCII bytes of address field in the command. If both bytes
 721          //     are valid ASCII Hex values then it constructs a decimal value from them
 722          //     and store it in MCP_temp8_1.
 723          //------------------------------------------------------------------------------
 724          static bit MCP_get_register_address(void)
 725          {
 726   1          U8 temp_byte;
 727   1      
 728   1          temp_byte = MCP_hex_to_dec(MCP_command[MCP_COMMAND_ADDR_INDEX + 0]);
 729   1          if (0xFF != temp_byte)
 730   1          {
 731   2              MCP_temp8_1 = temp_byte << 4;
 732   2              temp_byte = MCP_hex_to_dec(MCP_command[MCP_COMMAND_ADDR_INDEX + 1]);
 733   2              if (0xFF != temp_byte)
 734   2              {
 735   3                  MCP_temp8_1 += temp_byte;
 736   3                  return 0;
 737   3              }
 738   2          }
 739   1      
 740   1          return 1;
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 13  

 741   1      }
 742          
 743          //------------------------------------------------------------------------------
 744          // MCP_process_command
 745          // static bit MCP_process_command (void)
 746          //
 747          // Return Value:
 748          //     0: Command successfully processed
 749          //     1: Command processing failed
 750          //
 751          // Parameters:
 752          //     None
 753          //
 754          // Description:
 755          //     It is parses and processes the received command by performing command
 756          //     specific operation. It also prepares response if required by the command.
 757          //
 758          //------------------------------------------------------------------------------
 759          static bit MCP_process_command (void)
 760          {
 761   1          U8 bval;
 762   1          U8 digit_count;
 763   1      
 764   1          MCP_temp16_1 = 0;
 765   1      
 766   1          MCP_temp1 = MCP_get_register_address();
 767   1      
 768   1          if ('\n' == MCP_command[MCP_COMMAND_TYPE_INDEX])
 769   1          {
 770   2              MCP_temp16_1 = MCP_get_8bit_register(MCP_REG_FIRMWARE_REVISION);
 771   2      
 772   2              MCP_command[0] = 'B';
 773   2              MCP_command[1] = 'L';
 774   2              MCP_command[2] = 'D';
 775   2              MCP_command[3] = 'C';
 776   2              MCP_command[4] = 'R';
 777   2              MCP_command[5] = 'E';
 778   2              MCP_command[6] = 'F';
 779   2              MCP_command[7] = ' ';
 780   2      
 781   2              MCP_command_ptr = &MCP_command[8];
 782   2              MCP_send_ascii_value(MCP_temp16_1);
 783   2              *MCP_command_ptr++ = '\n';
 784   2      
 785   2              return 0;
 786   2          }
 787   1          else if (('R' == MCP_command[MCP_COMMAND_TYPE_INDEX + 0]) &&
 788   1                   ('S' == MCP_command[MCP_COMMAND_TYPE_INDEX + 1]) &&
 789   1                   ('T' == MCP_command[MCP_COMMAND_TYPE_INDEX + 2]))
 790   1          {
 791   2              // MCP_reset_callback() will generate software_reset(SWRSF).
 792   2              // MCP_init_registers() called during booting time.
 793   2              MCP_INIT_CMDPTR();
 794   2              MCP_reset_callback();
 795   2      
 796   2              MCP_reset_cmd = 1;
 797   2      
 798   2      //        MCP_init_registers();
 799   2              return 0;
 800   2          }
 801   1          else if (MCP_COMMAND_TEXT_MODE == MCP_cmd_type)
 802   1          {
 803   2              //Switch to TEXT mode
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 14  

 804   2              MCP_mode = MCP_TEXT_MODE;
 805   2              return 0;
 806   2          }
 807   1          else if (MCP_COMMAND_BIN_MODE == MCP_cmd_type)
 808   1          {
 809   2              //Switch to BIN mode
 810   2              MCP_mode = MCP_BINARY_MODE;
 811   2              MCP_INIT_CMDPTR();
 812   2              *MCP_command_ptr++ = 0x00;
 813   2      
 814   2              //First register for status update process
 815   2              MCP_temp8_2 = MCP_REG_FIRMWARE_REVISION;
 816   2              return 0;
 817   2          }
 818   1          else if ('=' == MCP_command[MCP_COMMAND_TYPE_INDEX])
 819   1          {
 820   2              MCP_temp16_1 = 0;
 821   2              digit_count = 0;
 822   2              for (MCP_command_ptr_2 = &MCP_command[MCP_COMMAND_DATA_INDEX];
 823   2                   MCP_command_ptr_2 < MCP_command_ptr; MCP_command_ptr_2++)
 824   2              {
 825   3                  digit_count++;
 826   3      
 827   3                  bval = *MCP_command_ptr_2 - '0';
 828   3                  if (9 >= bval)
 829   3                  {
 830   4                      MCP_temp16_1 = MCP_temp16_1 * 10 + bval;
 831   4                  }
 832   3                  else
 833   3                  {
 834   4                      break;
 835   4                  }
 836   3              }
 837   2      
 838   2              if (0 == MCP_temp1)
 839   2              {
 840   3                  if (MCP_REG_PRESENT_MOTOR_SPEED > MCP_temp8_1)
 841   3                  {
 842   4                      if (3 < digit_count)
 843   4                      {
 844   5                          MCP_INIT_CMDPTR();
 845   5                          return 1;
 846   5                      }
 847   4      
 848   4                      MCP_temp1 = MCP_set_8bit_register(MCP_temp8_1,
 849   4                                                                 (U8)MCP_temp16_1, 1);
 850   4                  }
 851   3                  else
 852   3                  {
 853   4                      if (5 < digit_count)
 854   4                      {
 855   5                          MCP_INIT_CMDPTR();
 856   5                          return 1;
 857   5                      }
 858   4      
 859   4                      MCP_temp1 = MCP_set_16bit_register(MCP_temp8_1,
 860   4                                                                     MCP_temp16_1, 1);
 861   4                  }
 862   3              }
 863   2      
 864   2              MCP_INIT_CMDPTR();
 865   2              return(MCP_temp1);
 866   2          }
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 15  

 867   1          else if ('?' == MCP_command[MCP_COMMAND_TYPE_INDEX])
 868   1          {
 869   2              MCP_INIT_CMDPTR();
 870   2      
 871   2              if (0 == MCP_temp1)
 872   2              {
 873   3                  MCP_temp1 = 1;
 874   3                  if (MCP_REG_PRESENT_MOTOR_SPEED > MCP_temp8_1)
 875   3                  {
 876   4                      if (MCP_REG_RESERVED_START > MCP_temp8_1)
 877   4                      {
 878   5                          MCP_temp16_1 = (U16)MCP_get_8bit_register(MCP_temp8_1);
 879   5                          MCP_send_ascii_value(MCP_temp16_1);
 880   5                          MCP_temp1 = 0;
 881   5                      }
 882   4                  }
 883   3                  else
 884   3                  {
 885   4                      if ((MCP_REG_PRESENT_MOTOR_SPEED <= MCP_temp8_1) &&
 886   4                          (MCP_REG_UNDEFINED_START     > MCP_temp8_1))
 887   4                      {
 888   5                          MCP_temp16_1 = MCP_get_16bit_register(MCP_temp8_1);
 889   5                          MCP_send_ascii_value(MCP_temp16_1);
 890   5                          MCP_temp1 = 0;
 891   5                      }
 892   4                  }
 893   3              }
 894   2      
 895   2              if (0 == MCP_temp1)
 896   2              {
 897   3                  *MCP_command_ptr++ = '\n';
 898   3              }
 899   2      
 900   2              return(MCP_temp1);
 901   2          }
 902   1          else if ('#' == MCP_command[MCP_COMMAND_TYPE_INDEX])
 903   1          {
 904   2              MCP_INIT_CMDPTR();
 905   2              MCP_temp16_1 = MCP_command[MCP_COMMAND_DATA_INDEX + 0] - '0';
 906   2      
 907   2              if (0 == MCP_temp1)
 908   2              {
 909   3                  MCP_temp1 = MCP_status_update_register(MCP_temp8_1, MCP_temp16_1);
 910   3              }
 911   2      
 912   2              return(MCP_temp1);
 913   2          }
 914   1      #ifdef FEATURE_PID_TUNE_FUNCTION
                  else if (('T' == MCP_command[MCP_COMMAND_TYPE_INDEX + 0]) &&
                           ('N' == MCP_command[MCP_COMMAND_TYPE_INDEX + 1]))
                  {
                      MCP_temp16_1 = MCP_get_16bit_register(MCP_REG_PRESENT_MOTOR_SPEED);
              
                      if (0 == MCP_temp16_1)
                      {
                          digit_count = 0;
                          MCP_temp16_1 = 0;
                          for (MCP_command_ptr_2 = &MCP_command[MCP_COMMAND_DATA_INDEX - 1];
                               MCP_command_ptr_2 < MCP_command_ptr; MCP_command_ptr_2++)
                          {
                              bval = *MCP_command_ptr_2 - '0';
                              if (9 >= bval)
                              {
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 16  

                                  digit_count++;
                                  if (5 < digit_count)
                                  {
                                      MCP_INIT_CMDPTR();
                                      return 1;
                                  }
              
                                  MCP_temp16_1 = MCP_temp16_1 * 10 + bval;
                              }
                              else
                              {
                                  break;
                              }
                          }
                          MCP_command_ptr_2++;    // Skip past non-number character
                          digit_count = 0;
                          MCP_temp16_2 = 0;
                          for (; MCP_command_ptr_2 < MCP_command_ptr; MCP_command_ptr_2++)
                          {
                              bval = *MCP_command_ptr_2 - '0';
                              if (9 >= bval)
                              {
                                  digit_count++;
                                  if (5 < digit_count)
                                  {
                                      MCP_INIT_CMDPTR();
                                      return 1;
                                  }
              
                                  MCP_temp16_2 = MCP_temp16_2 * 10 + bval;
                              }
                              else
                              {
                                  break;
                              }
                          }
              
                          MCP_cmd_type = MCP_COMMAND_TUNE_PID;
              
                          MCP_INIT_CMDPTR();
                          //Note: Remaining part of this command is processed in MCP_Task()
                          return 0;
                      }
              
                      else
                      {
                          MCP_INIT_CMDPTR();
                          return 1;
                      }
                  }
              #endif
 981   1          MCP_INIT_CMDPTR();
 982   1          return 1;
 983   1      }
 984          
 985          //------------------------------------------------------------------------------
 986          // MCP_update_status
 987          // static void MCP_update_status (void)
 988          //
 989          // Return Value:
 990          //     None
 991          //
 992          // Parameters:
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 17  

 993          //     None
 994          //
 995          // Description:
 996          //     It reads all enabled registers, one at a time, and stores address and
 997          //     corresponding value into status buffer.
 998          //
 999          // WARNING:
1000          //     If data is not taken out (get) from status buffer at a sufficient rate,
1001          //     it may over-write unsent data.
1002          //------------------------------------------------------------------------------
1003          static void MCP_update_status (void)
1004          {
1005   1          if (MCP_REG_RESERVED_START > MCP_temp8_2)
1006   1          {
1007   2              if (MCP_is_8bit_status_update_enabled(MCP_temp8_2))
1008   2              {
1009   3                  MCP_temp16_1 = MCP_get_8bit_register(MCP_temp8_2);
1010   3      
1011   3                  //Send register address in binary form
1012   3                  MCP_status_add(MCP_temp8_2);
1013   3                  MCP_status_INCPTR(MCP_status_tail);
1014   3      
1015   3                  //Send 8-bit value
1016   3                  MCP_status_add((U8)(MCP_temp16_1 & 0x00FF));
1017   3                  MCP_status_INCPTR(MCP_status_tail);
1018   3              }
1019   2              MCP_temp8_2++;
1020   2          }
1021   1          else if (MCP_REG_PRESENT_MOTOR_SPEED > MCP_temp8_2)
1022   1          {
1023   2              // Skip reserved registers
1024   2              MCP_temp8_2 = MCP_REG_PRESENT_MOTOR_SPEED;
1025   2          }
1026   1          else if (MCP_REG_UNDEFINED_START > MCP_temp8_2)
1027   1          {
1028   2              if (MCP_is_16bit_status_update_enabled(MCP_temp8_2))
1029   2              {
1030   3                  MCP_temp16_1 = MCP_get_16bit_register(MCP_temp8_2);
1031   3      
1032   3                  //Send register address in binary form
1033   3                  MCP_status_add(MCP_temp8_2);
1034   3                  MCP_status_INCPTR(MCP_status_tail);
1035   3      
1036   3                  //Send upper byte of 16 bit value
1037   3                  MCP_status_add((U8)(MCP_temp16_1 >> 8));
1038   3                  MCP_status_INCPTR(MCP_status_tail);
1039   3      
1040   3                  //Send lower byte of 16 bit value
1041   3                  MCP_status_add((U8)(MCP_temp16_1 & 0x00FF));
1042   3                  MCP_status_INCPTR(MCP_status_tail);
1043   3              }
1044   2              MCP_temp8_2 += 2;
1045   2          }
1046   1          else
1047   1          {
1048   2              // Skip undefined registers and start again
1049   2              MCP_temp8_2 = MCP_REG_FIRMWARE_REVISION;
1050   2          }
1051   1      }
1052          
1053          //------------------------------------------------------------------------------
1054          // MCP_send_ascii_value
1055          // static void MCP_send_ascii_value (U16 value)
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 18  

1056          //
1057          // Return Value:
1058          //     None
1059          //
1060          // Parameters:
1061          //     value - the 16-bit value to convert to ASCII decimal
1062          //
1063          // Description:
1064          //     This function calls MCP_dec_to_ascnumbuf() to converts value to ASCII
1065          //     decimal and stores it in MCP_command[] buffer. It is normally called in
1066          //     in response to some commands and the value is normally register contents.
1067          //
1068          //------------------------------------------------------------------------------
1069          static void MCP_send_ascii_value (U16 value)
1070          {
1071   1          U8 idx;
1072   1      
1073   1          // Convert it to hex number format in reverse byte order
1074   1          idx = MCP_dec_to_ascnumbuf(value);
1075   1      
1076   1          for (; idx != 0xff; idx--)
1077   1          {
1078   2              *MCP_command_ptr++ = MCP_numcnvbuf[idx];
1079   2          }
1080   1      }
1081          
1082          #else //BUILD_FOR_PROTOCOL
              //------------------------------------------------------------------------------
              // APIs
              //------------------------------------------------------------------------------
              
              //Pointers to call back functions
              U8 (* MCP_tune_callback) (U16, U16);
              bit (* MCP_reset_callback) (void);
              
              //------------------------------------------------------------------------------
              // MCP_init:
              // void MCP_init (void)
              //
              // Return Value:
              //     None
              //
              // Parameters:
              //     None
              //
              // Description:
              //     This function initializes MCP Registers.
              //------------------------------------------------------------------------------
              void MCP_init (void)
              {
                  MCP_init_registers();
              }
              
              //------------------------------------------------------------------------------
              // MCP_task:
              // void MCP_task (void)
              //
              // Return Value:
              //     None
              //
              // Parameters:
              //     None
              //
C51 COMPILER V9.53.0.0   MCP_CORE                                                          01/24/2020 09:29:51 PAGE 19  

              // Description:
              //     This is a dummy function.
              //------------------------------------------------------------------------------
              void MCP_task (void)
              {
              
              }
              
              //------------------------------------------------------------------------------
              // MCP Debug Print
              // void MCP_debug_Print (const U8 *str, U32 value)
              //
              // Return Value:
              //     None
              //
              // Parameters:
              //     Debug string/message to be printed.
              //
              // Description:
              //     This is a dummy function.
              //------------------------------------------------------------------------------
              #ifdef BUILD_FOR_DEBUG
              
              void MCP_debug_print (const U8 * data str, U32 value)
              {
              
              }
              #endif //BUILD_FOR_DEBUG
              
              #endif //BUILD_FOR_PROTOCOL
1149          
1150          //------------------------------------------------------------------------------
1151          // End Of File
1152          //------------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       8
   IDATA SIZE       =     30    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
