C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MTRAPP
OBJECT MODULE PLACED IN .\src\mtrapp.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\A92862\
                    -SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\mtrapp.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FL
                    -OATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_
                    -BLDC_PORT\inc;C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\inc\config;C:/SiliconLabs/SimplicityStudio
                    -/v4/developer/sdks/8051/v4.1.7//kits/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v4/developer/sdk
                    -s/8051/v4.1.7//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/common/bsp;C:/Silicon
                    -Labs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/EFM8BB1_LCK/config;C:/SiliconLabs/SimplicityStudio/v4/develope
                    -r/sdks/8051/v4.1.7//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8B
                    -B1/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB1/peripheral_driver/inc) PRINT(.\src\
                    -mtrapp.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\mtrapp.OBJ)

line level    source

   1          /*
   2           * mtrapp.c
   3           *
   4           *  Created on: Jan 20, 2020
   5           *      Author: a92862
   6           */
   7          
   8          #include "bldcdk.h"
*** WARNING C322 IN LINE 130 OF \Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\inc\BLDC_RD_Build_Params.h
             -: unknown identifier
   9          
  10          //-----------------------------------------------------------------------------
  11          // Global Constants
  12          //-----------------------------------------------------------------------------
  13          
  14          #define MTRAPP_ATOMIC_ACCESS_START()     \
  15          do                                       \
  16          {                                        \
  17              saved_ea = EA;                       \
  18              EA = 0;                              \
  19          } while (0)
  20          
  21          #define MTRAPP_ATOMIC_ACCESS_END()       \
  22          do                                       \
  23          {                                        \
  24              EA = saved_ea;                       \
  25          } while (0)
  26          
  27          
  28          //-----------------------------------------------------------------------------
  29          // Global Variables
  30          //-----------------------------------------------------------------------------
  31          // Additional motor current to accumulate to perform further averaging
  32          #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
  33          static SEG_DATA U16     prev_target_rpm;
  34          #endif
  35          static SEG_XDATA U16     read_speed_interval;
  36          
  37          #if BLDC_RD_RPM_PWM_SRC == PWM_SPEED_SOURCE
              SEG_XDATA UU32          prev_edge;
              SEG_XDATA UU32          new_edge;
              bit                     last_edge_event;
              #endif
  42          static bit speed_ctrl_by_pc;
  43          static bit start_by_pc;
  44          static SEG_XDATA U16    pot_reading;
  45          
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 2   

  46          //-----------------------------------------------------------------------------
  47          // MTRAPP_init
  48          //-----------------------------------------------------------------------------
  49          //
  50          // Return Value : None
  51          // Parameters   : None
  52          //
  53          // initialization for application level.
  54          //-----------------------------------------------------------------------------
  55          void MTRAPP_init()
  56          {
  57   1          read_speed_interval = DEFAULT_SPEED_ADC_INTERVAL;
  58   1          SLW_oc_debounce = MCP_get_8bit_register(MCP_REG_OVER_CURRENT_PERSISTANCE);
  59   1          SLW_current_limit = MCP_get_8bit_register(MCP_REG_OVER_CURRENT_THRESHOLD);
  60   1          SLW_motor_max_rpm = MCP_get_16bit_register(MCP_REG_MAXIMUM_OPERATIONAL_SPEED);
  61   1          speed_ctrl_by_pc = 0;
  62   1          start_by_pc = 0;
  63   1      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
  64   1          SLW_target_rpm = 0;
  65   1      #endif
  66   1          SLW_target_pwm_duty = 0;
  67   1          pot_reading = 0;
  68   1      #if BLDC_RD_RPM_PWM_SRC == PWM_SPEED_SOURCE
                  // enable port match interrupt
                  EIE1 |= (0x01<<1);
              #endif
  72   1      }
  73          
  74          //-----------------------------------------------------------------------------
  75          // MTRAPP_task
  76          //-----------------------------------------------------------------------------
  77          //
  78          // Return Value : None
  79          // Parameters   : None
  80          //
  81          // Application level task.
  82          // NOTE : application should call SL_MTR_motor() regularly to keep motor
  83          // running.
  84          //-----------------------------------------------------------------------------
  85          void MTRAPP_task()
  86          {
  87   1      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
  88   1          U16 SEG_XDATA Pg, Ig;
  89   1      #endif
  90   1          static U8 last_report;
  91   1          U8 tmp;
  92   1          bit run_dir;
  93   1      
  94   1          // keep motor running and manage state of motor
  95   1          // NOTE : application should call this regularly.
  96   1          SL_MTR_motor();
  97   1      
  98   1          tmp = is_btn1_pressed();
  99   1          if( MOTOR_STOPPED == SLR_motor_state )
 100   1          {
 101   2              if (tmp || start_by_pc)
 102   2              {
 103   3                  if( !SLR_motor_stalled)
 104   3                  {
 105   4                      if(ADC0CN0 & 0x90)
 106   4                      {
 107   5                          // SL_MTR_start_motor need CPT0MX_IMEASURE pin which is
 108   5                          // same as IMEAS_ADCMX.
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 3   

 109   5                          // wait if adc in progress by ADC_task().
 110   5                          // disconnect all pins
 111   5                          ADC0MX = 0x1F;
 112   5                      }
 113   4      
 114   4                      if (tmp)
 115   4                      {
 116   5                          // Button 1 pressed - we reset speed_ctrl_by_pc
 117   5                          speed_ctrl_by_pc = 0;
 118   5                      }
 119   4      
 120   4                      SL_MTR_start_motor();
 121   4                      // Configure LED0 here - in case we share LED with buttons
 122   4                      // In ref design, BTN0 and LED0 are shared.
 123   4                      // If FEATURE_LED0 is not defined, this macro does not
 124   4                      // generate any code.
 125   4                      CONFIG_LED0();
 126   4                      // update direction register.
 127   4                      MCP_set_8bit_register(MCP_REG_PRESENT_MOTOR_DIRECTION, \
 128   4                              SLW_user_direction, 0);
 129   4                  }
 130   3                  start_by_pc = 0;
 131   3              }
 132   2      
 133   2              // --------------------------------------------------------------------
 134   2              // read motor direction changes
 135   2              MTRAPP_read_direction();
 136   2      
 137   2              // --------------------------------------------------------------------
 138   2              // followings can be move to mtrapp_init(), if application need only
 139   2              // default(or fixed) value.
 140   2              SLW_oc_debounce = MCP_get_8bit_register(MCP_REG_OVER_CURRENT_PERSISTANCE);
 141   2              SLW_current_limit = MCP_get_8bit_register(MCP_REG_OVER_CURRENT_THRESHOLD);
 142   2              SLW_motor_max_rpm = MCP_get_16bit_register(MCP_REG_MAXIMUM_OPERATIONAL_SPEED);
 143   2              SL_MTR_change_num_poles( MCP_get_8bit_register \
 144   2                      (MCP_REG_MOTOR_POLE_PAIRS_COUNT) * 2 );
 145   2      #if BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
                      SLW_acceleration_step_size = \
                              MCP_get_16bit_register(MCP_REG_ACCELERATION_STEP_SIZE);
                      SLW_deceleration_step_size = \
                              MCP_get_16bit_register(MCP_REG_DECELERATION_STEP_SIZE);
              #endif
 151   2      
 152   2      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
 153   2              Pg = MCP_get_16bit_register(MCP_REG_PROPORTIONAL_GAIN);
 154   2              Ig = MCP_get_16bit_register(MCP_REG_INTEGRAL_GAIN);
 155   2              SL_MTR_change_pid_gain(Pg, Ig);
 156   2      #endif
 157   2          }
 158   1          else if( MOTOR_RUNNING == SLR_motor_state )
 159   1          {
 160   2      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
 161   2              if (tmp || !SLW_target_rpm )
 162   2      #elif BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
                      if (tmp || !SLW_target_pwm_duty )
              #endif
 165   2      
 166   2              {
 167   3                  SL_MTR_stop_motor();
 168   3      #if defined(FEATURE_HYPERDRIVE)
                          // The following does nothing if FEATURE_LED0 is not enabled
                          LED0_OFF();
              #endif
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 4   

 172   3                  // Re-configure BTN0 because this is shared with LED0 in
 173   3                  // reference design kit.
 174   3              }
 175   2          }
 176   1          // Enable stream data even motor stopped.
 177   1          tmp = (U8)SL_MTR_time();
 178   1          if((last_report != tmp) && (tmp & RPM_REPORT_PERIOD == RPM_REPORT_PERIOD))
 179   1          {
 180   2              last_report = tmp;
 181   2              MCP_set_16bit_register(MCP_REG_PRESENT_MOTOR_SPEED,
 182   2                      SLR_motor_current_rpm, 0);
 183   2              MCP_set_16bit_register(MCP_REG_ACTIVE_PWM_DUTY_CYCLE, SLR_pwm_duty, 0);
 184   2              run_dir = MCP_get_8bit_register(MCP_REG_PRESENT_MOTOR_DIRECTION);
 185   2              MCP_set_8bit_register(MCP_REG_PRESENT_MOTOR_DIRECTION, \
 186   2                      run_dir, 0);
 187   2          }
 188   1      
 189   1          // -----------------------------------------------------------------------
 190   1          // read new target speed
 191   1          MTRAPP_read_target_speed();
 192   1      
 193   1          // -----------------------------------------------------------------------
 194   1          // update average current to register 0x32.
 195   1          MCP_set_16bit_register(MCP_REG_MOTOR_COIL_CURRENT,SLR_motor_current,0);
 196   1      
 197   1          // -----------------------------------------------------------------------
 198   1          // read Vmotor and update register. 0x34
 199   1          // update reg 0x34
 200   1      #ifdef FEATURE_MEAS_VMDC
 201   1          MCP_set_16bit_register(MCP_REG_MOTOR_OPERATING_VOLTAGE,SLR_motor_voltage, 0);
 202   1      #endif
 203   1      }
 204          
 205          //-----------------------------------------------------------------------------
 206          // MTRAPP_read_direction
 207          //-----------------------------------------------------------------------------
 208          //
 209          // Return Value : None
 210          // Parameters   : None but it will change global variable SLW_user_direction.
 211          //
 212          //  read NEXT motor running direction according to build parameter.
 213          //  In case of DIRECTION_BY_BUTTON, when button released
 214          //  SLW_user_direction is updated.
 215          //-----------------------------------------------------------------------------
 216          void MTRAPP_read_direction(void)
 217          {
 218   1          static bit wait_release=1;
 219   1      
 220   1          if(wait_release == 1)
 221   1          {
 222   2              if( IS_BTN0_PRESSED() )
 223   2              {
 224   3                  wait_release = 0;
 225   3              }
 226   2          }
 227   1          else if( !IS_BTN0_PRESSED() && (wait_release == 0))
 228   1          {
 229   2              SLW_user_direction = ~SLW_user_direction;
 230   2              MCP_set_8bit_register(MCP_REG_TARGET_MOTOR_DIRECTION, \
 231   2                      (U8)SLW_user_direction, 0);
 232   2              wait_release = 1;
 233   2          }
 234   1          // read register. 0x02 (0:CW, 1:CCW)
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 5   

 235   1          SLW_user_direction = MCP_get_8bit_register(MCP_REG_TARGET_MOTOR_DIRECTION);
 236   1      }
 237          
 238          
 239          //-----------------------------------------------------------------------------
 240          // MTRAPP_read_target_speed
 241          //-----------------------------------------------------------------------------
 242          //
 243          // Return Value : None
 244          // Parameters   : None but it will change global variable SLW_target_rpm.
 245          //
 246          //  set SLW_target_rpm or SLW_target_pwm_duty according to build-time parameter.
 247          //  Those target values are saved to register accordingly.
 248          //  To reach 100% of target duty cycle or SLW_motor_max_rpm in any case,
 249          //  just added small constant to the adc result.
 250          //-----------------------------------------------------------------------------
 251          void MTRAPP_read_target_speed(void)
 252          {
 253   1      #if BLDC_RD_RPM_PWM_SRC == POT_SPEED_SOURCE
 254   1      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
 255   1          static U16 last_read_speed_time;
 256   1          U16 temp;
 257   1      
 258   1          if( ((U16)SL_MTR_time() - last_read_speed_time) < read_speed_interval )
 259   1          {
 260   2              return;
 261   2          }
 262   1          last_read_speed_time = (U16)SL_MTR_time();
 263   1      
 264   1          if (speed_ctrl_by_pc || ( MOTOR_STOPPED == SLR_motor_state ))
 265   1          {
 266   2              // read reg 0x3C (target rpm)
 267   2              temp = MCP_get_16bit_register(MCP_REG_TARGET_MOTOR_SPEED);
 268   2              if( SLW_target_rpm != temp )
 269   2              {
 270   3                  if (temp == 1)
 271   3                  {
 272   4                      // Special case of target speed of 1.
 273   4                      start_by_pc = 1;
 274   4      
 275   4                      // Restore target speed
 276   4                      MCP_set_16bit_register(MCP_REG_TARGET_MOTOR_SPEED, SLW_target_rpm, 0);
 277   4                  }
 278   3                  else
 279   3                  {
 280   4                      SLW_target_rpm = temp;
 281   4                  }
 282   3                  speed_ctrl_by_pc = 1;
 283   3              }
 284   2          }
 285   1      
 286   1          // read latest adc result....
 287   1          temp = adc_result[ADC_MUX_POT];
 288   1          // CW : Increase, CCW : Decrease speed
 289   1          temp = MAX_ADC_VALUE - temp;
 290   1          // Just added some amount to reach SLW_motor_max_rpm(or 100% duty) in any case.
 291   1          temp += (MAX_ADC_VALUE>>5);      // about 3%
 292   1      
 293   1          pot_reading = ((U32)(SLW_motor_max_rpm * (U32)temp))>>ADC_RESOLUTION;
 294   1          pot_reading = (prev_target_rpm + pot_reading)>>1;
 295   1          prev_target_rpm = pot_reading;
 296   1          if( pot_reading < APP_MOTOR_MIN_RPM )
 297   1          {
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 6   

 298   2              pot_reading = APP_MOTOR_MIN_RPM;
 299   2          }
 300   1      
 301   1          if ( !speed_ctrl_by_pc )
 302   1          {
 303   2              // Use POT when speed is not controlled by PC
 304   2              SLW_target_rpm = pot_reading;
 305   2              // set register
 306   2              MCP_set_16bit_register(MCP_REG_TARGET_MOTOR_SPEED, SLW_target_rpm, 0);
 307   2          }
 308   1      
 309   1      #elif BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
                  static U16 last_read_speed_time;
                  U16 temp;
              
                  if( ((U16)SL_MTR_time() - last_read_speed_time) < read_speed_interval )
                  {
                      return;
                  }
                  last_read_speed_time = (U16)SL_MTR_time();
              
                  if (speed_ctrl_by_pc || ( MOTOR_STOPPED == SLR_motor_state ))
                  {
                      // read reg 0x3C (target rpm)
                      temp = MCP_get_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE);
                      if( SLW_target_pwm_duty != temp )
                      {
                          if (temp == 1)
                          {
                              // Special case of target speed of 1.
                              start_by_pc = 1;
              
                              // Restore target PWM duty cycle
                              MCP_set_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE, SLW_target_pwm_duty, 0);
                          }
                          else
                          {
                              SLW_target_pwm_duty = temp;
                          }
                          speed_ctrl_by_pc = 1;
                      }
                  }
              
                  // read latest adc result....
                  temp = adc_result[ADC_MUX_POT];
                  // CW : Increase, CCW : Decrease speed
                  temp = MAX_ADC_VALUE - temp;
                  // Just added some amount to reach SLW_motor_max_rpm(or 100% duty) in any case.
                  temp += (MAX_ADC_VALUE>>5);      // about 3%
              
                  if( temp > MAX_ADC_VALUE)
                  {
                      pot_reading = MAX_USER_PWM_VALUE;
                  }
                  else
                  {
                      // target pwm = 16 bit value.
                      pot_reading = (temp<<(16-ADC_RESOLUTION));
                  }
              
                  if ( !speed_ctrl_by_pc )
                  {
                      // Use POT when speed is not controlled by PC
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 7   

                      SLW_target_pwm_duty = pot_reading;
                      // set register (16bit pwm duty cycle)
                      MCP_set_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE, \
                                             SLW_target_pwm_duty, 0);
                  }
              
              #endif
 368   1      #elif BLDC_RD_RPM_PWM_SRC == PWM_SPEED_SOURCE
                  MTRAPP_read_pwm_input();
              #endif
 371   1      }
 372          
 373          
 374          #if BLDC_RD_RPM_PWM_SRC == PWM_SPEED_SOURCE
              //-----------------------------------------------------------------------------
              // MTRAPP_read_pwm_input
              //-----------------------------------------------------------------------------
              //
              // Return Value : None
              // Parameters   : None
              //
              //  Assuming the input frequency is 50~100Hz (20ms ~ 10ms)
              //  Measuring % of high period.
              //  Ex. target_rpm = MOTOR_MAX_RPM*high_period/(high_period+low_period)
              //-----------------------------------------------------------------------------
              void MTRAPP_read_pwm_input(void)
              {
                  UU32 SEG_XDATA tmp1, tmp2;
                  UU16 SEG_XDATA period;
                  U16 SEG_XDATA period_low, period_high;
                  U16 temp;
                  bit edge_event;
              
                  EA = 0;
                  edge_event = last_edge_event;
                  tmp1.U32 = prev_edge.U32;
                  tmp2.U32 = new_edge.U32;
                  EA = 1;
              
                  // to avoid overflow at high speed (200K rpm)
                  period.U16 = (U16)((tmp2.U32 - tmp1.U32)>>8);
                  // rising edge (end or start of period)
                  if( edge_event)
                  {
                      period_low = period.U16;
                  }
                  // falling edge (end of duty)
                  else
                  {
                      period_high = period.U16;
                  }
              
              #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
                  if (speed_ctrl_by_pc || ( MOTOR_STOPPED == SLR_motor_state ))
                  {
                      temp = MCP_get_16bit_register(MCP_REG_TARGET_MOTOR_SPEED);
                      if( SLW_target_rpm != temp )
                      {
                          if (temp == 1)
                          {
                              // Special case of target speed of 1.
                              start_by_pc = 1;
              
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 8   

                              // Restore target speed
                              MCP_set_16bit_register(MCP_REG_TARGET_MOTOR_SPEED, SLW_target_rpm, 0);
                          }
                          else
                          {
                              SLW_target_rpm = temp;
                          }
                          speed_ctrl_by_pc = 1;
                      }
                  }
              
                  pot_reading = (U16)( ((U32)SLW_motor_max_rpm * period_high ) / \
                          (U32)( period_high+period_low) );
                  // Just added some amount.
                  pot_reading += (MOTOR_MAX_RPM>>5);
                  if(pot_reading < APP_MOTOR_MIN_RPM)
                      pot_reading = APP_MOTOR_MIN_RPM;
              
                  if ( !speed_ctrl_by_pc )
                  {
                      // Use POT when speed is not controlled by PC
                      SLW_target_rpm = pot_reading;
                      // set register
                      MCP_set_16bit_register(MCP_REG_TARGET_MOTOR_SPEED, SLW_target_rpm, 0);
                  }
              
              #elif BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
                  if (speed_ctrl_by_pc || ( MOTOR_STOPPED == SLR_motor_state ))
                  {
                      // read reg 0x3C (target rpm)
                      temp = MCP_get_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE);
                      if( SLW_target_pwm_duty != temp )
                      {
                          if (temp == 1)
                          {
                              // Special case of target speed of 1.
                              start_by_pc = 1;
              
                              // Restore target PWM duty cycle
                              MCP_set_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE, SLW_target_pwm_duty, 0);
                          }
                          else
                          {
                              SLW_target_pwm_duty = temp;
                          }
                          speed_ctrl_by_pc = 1;
                      }
                  }
              
                  pot_reading = (U16)( ( (U32)MAX_USER_PWM_VALUE * period_high ) / \
                          (U32)( period_high + period_low ) );
                  // Just added some amount.
                  pot_reading += (MAX_USER_PWM_VALUE>>5);
                  if(pot_reading < (MAX_USER_PWM_VALUE>>5))
                      pot_reading = MAX_USER_PWM_VALUE;
                  else if(pot_reading < SLR_minimum_duty.U16)
                      pot_reading = SLR_minimum_duty.U16;
              
              
                  if ( !speed_ctrl_by_pc )
                  {
                      // Use POT when speed is not controlled by PC
                      SLW_target_pwm_duty = pot_reading;
C51 COMPILER V9.53.0.0   MTRAPP                                                            01/20/2020 13:39:21 PAGE 9   

                      // set register (16bit pwm duty cycle)
                      MCP_set_16bit_register(MCP_REG_TARGET_PWM_DUTY_CYCLE, \
                                             SLW_target_pwm_duty, 0);
                  }
              #endif
              }
              INTERRUPT(PORT_MATCH_ISR, INTERRUPT_PORT_MATCH)
              {
                  static U8 ovf;
              
                  prev_edge.U32 = new_edge.U32;
                  SL_MTR_GET_32BIT_TIME(new_edge);
              
                  last_edge_event = (PWMIN_MAT != (1<<PWMIN_BIT));
                  // set next port miss match event
                  PWMIN_MAT ^= (1<<PWMIN_BIT);
              }
              #endif
 505          
 506          
*** WARNING C316 IN LINE 506 OF C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\mtrapp.c: unterminat
             -ed conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    603    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
