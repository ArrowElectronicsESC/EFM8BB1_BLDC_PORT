C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MOTOR
OBJECT MODULE PLACED IN .\src\motor.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\A92862\
                    -SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\motor.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLO
                    -ATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_B
                    -LDC_PORT\inc;C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\inc\config;C:/SiliconLabs/SimplicityStudio/
                    -v4/developer/sdks/8051/v4.1.7//kits/common/drivers/efm8_retargetserial;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks
                    -/8051/v4.1.7//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/common/bsp;C:/SiliconL
                    -abs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/EFM8BB1_LCK/config;C:/SiliconLabs/SimplicityStudio/v4/developer
                    -/sdks/8051/v4.1.7//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB
                    -1/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8BB1/peripheral_driver/inc) PRINT(.\src\m
                    -otor.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\motor.OBJ)

line level    source

   1          /*
   2           * motor.c
   3           *
   4           *  Created on: Jan 16, 2020
   5           *      Author: a92862
   6           */
   7          
   8          
   9          #include "bldcdk.h"
*** WARNING C322 IN LINE 130 OF \Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\inc\BLDC_RD_Build_Params.h
             -: unknown identifier
  10          
  11          
  12          //-----------------------------------------------------------------------------
  13          // Global Constants
  14          //-----------------------------------------------------------------------------
  15          #define MTR_ATOMIC_ACCESS_START() \
  16          do                                \
  17          {                                 \
  18              saved_ea = IE_EA;                \
  19              IE_EA = 0;                       \
  20          } while (0)
  21          
  22          #define MTR_ATOMIC_ACCESS_END()   \
  23          do                                \
  24          {                                 \
  25              IE_EA = saved_ea;                \
  26          } while (0)
  27          
  28          //-----------------------------------------------------------------------------
  29          // Global Variables
  30          //-----------------------------------------------------------------------------
  31          // Table for blind starting. Additional values are calculated in the function to
  32          // save code space.
  33          // Please refer to AN794 for more details derived.
  34          // IMPORTANT.  Please update _LAST_INIT_START_DELAY in BLDC_RD_System.h if
  35          //             start_delay[2] is modified
  36          const U16 code start_delay[NO_OF_STARTUP_DELAY] = {50000, 30902, 23863};
  37          
  38          // sequence of open phase : C, A, B, C, A, B ==> CW
  39          // comparator mux : CMP0MX = CMX0N[7:4]:CMX0P[3:0]
  40          // Zero crossing : Falling edge of comparator output.
  41          // Falling bemf : CP0N = VMY(P0.3) CP0P=VMA,VMB, VMC (P0.0~P0.2)
  42          // Rising bemf  : CP0N = VMA,VMB,VMC(P0.0~P0.2) CP0P=VMY(P0.3)
  43          // comMux[0~5] is for Falling bemf
  44          // comMux[6~11] is for Rising bemf
  45          const U8 code compMux[12] = {
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 2   

  46              (CPMUX_Y << 4) | CPMUX_C,
  47              (CPMUX_Y << 4) | CPMUX_A,
  48              (CPMUX_Y << 4) | CPMUX_B,
  49              (CPMUX_Y << 4) | CPMUX_C,
  50              (CPMUX_Y << 4) | CPMUX_A,
  51              (CPMUX_Y << 4) | CPMUX_B,
  52              (CPMUX_C << 4)| CPMUX_Y,
  53              (CPMUX_A << 4)| CPMUX_Y,
  54              (CPMUX_B << 4)| CPMUX_Y,
  55              (CPMUX_C << 4)| CPMUX_Y,
  56              (CPMUX_A << 4)| CPMUX_Y,
  57              (CPMUX_B << 4)| CPMUX_Y
  58          };
  59          
  60          #if BLDC_RD_PWM_METHOD == H_BRIDGE_HIGH_SIDE_PWM
              // high side pwm scheme with Si8230
              // 1111 0111 : P1.3(PWM),P1.4(L): Phase A->B energized, C open
              // 0111 1111 : P1.4(L),P1.7(PWM): Phase C->B energized, A open
              // 0111 1111 : P1.2(L),P1.7(PWM): Phase C->A energized, B open
              // 1101 1111 : P1.2(L),P1.5(PWM): Phase B->A energized, C open
              // 1101 1111 : P1.5(PWM),P1.6(L): Phase B->C energized, A open
              // 1111 0111 : P1.3(PWM),P1.6(L): Phase A->C energized, B open
              const U8 code skipPattern[6] = {
                  ~MOTDRV_AH_MASK, ~MOTDRV_CH_MASK, ~MOTDRV_CH_MASK,
                  ~MOTDRV_BH_MASK, ~MOTDRV_BH_MASK, ~MOTDRV_AH_MASK
              };
              #elif BLDC_RD_PWM_METHOD == H_BRIDGE_LOW_SIDE_PWM
              // low side pwm scheme with Si8230
              // 1110 1111 : P1.3(H),P1.4(PWM): Phase A->B energized, C open
              // 1110 1111 : P1.4(PWM),P1.7(H): Phase C->B energized, A open
              // 1111 1011 : P1.2(PWM),P1.7(H): Phase C->A energized, B open
              // 1111 1011 : P1.2(PWM),P1.5(H): Phase B->A energized, C open
              // 1011 1111 : P1.5(H),P1.6(PWM): Phase B->C energized, A open
              // 1011 1111 : P1.3(H),P1.6(PWM): Phase A->C energized, B open
              const U8 code skipPattern[6] = {
                  ~MOTDRV_BL_MASK, ~MOTDRV_BL_MASK, ~MOTDRV_AL_MASK,
                  ~MOTDRV_AL_MASK, ~MOTDRV_CL_MASK, ~MOTDRV_CL_MASK
              };
              #elif BLDC_RD_PWM_METHOD == H_BRIDGE_MIXED_MODE_PWM
  85          // mixed mode pwm scheme with Si8230
  86          // Falling BEMF (rising_bemf = 1 at setup time):
  87          // 1110 1111 : P1.3(H),P1.4(PWM): Phase A->B energized, C open
  88          // 1110 1111 : P1.4(PWM),P1.7(H): Phase C->B energized, A open
  89          // 1111 1011 : P1.2(PWM),P1.7(H): Phase C->A energized, B open
  90          // 1111 1011 : P1.2(PWM),P1.5(H): Phase B->A energized, C open
  91          // 1011 1111 : P1.5(H),P1.6(PWM): Phase B->C energized, A open
  92          // 1011 1111 : P1.3(H),P1.6(PWM): Phase A->C energized, B open
  93          
  94          // Rising BEMF (rising_bemf = 0 at setup time):
  95          // 1111 0111 : P1.3(PWM),P1.4(L): Phase A->B energized, C open
  96          // 0111 1111 : P1.4(L),P1.7(PWM): Phase C->B energized, A open
  97          // 0111 1111 : P1.2(L),P1.7(PWM): Phase C->A energized, B open
  98          // 1101 1111 : P1.2(L),P1.5(PWM): Phase B->A energized, C open
  99          // 1101 1111 : P1.5(PWM),P1.6(L): Phase B->C energized, A open
 100          // 1111 0111 : P1.3(PWM),P1.6(L): Phase A->C energized, B open
 101          
 102          // First index is the rising_bemf flag
 103          const U8 code skipPattern[2][6] = {
 104                  {
 105                      ~MOTDRV_AH_MASK, ~MOTDRV_CH_MASK, ~MOTDRV_CH_MASK,
 106                      ~MOTDRV_BH_MASK, ~MOTDRV_BH_MASK, ~MOTDRV_AH_MASK
 107                  },
 108                  {
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 3   

 109                      ~MOTDRV_BL_MASK, ~MOTDRV_BL_MASK, ~MOTDRV_AL_MASK,
 110                      ~MOTDRV_AL_MASK, ~MOTDRV_CL_MASK, ~MOTDRV_CL_MASK
 111                  },
 112          };
 113          #endif
 114          
 115          const U8 code freeterminal[6] = {
 116              FILTERED_C_MASK, FILTERED_A_MASK, FILTERED_B_MASK,
 117              FILTERED_C_MASK, FILTERED_A_MASK, FILTERED_B_MASK
 118          };
 119          const U8 code active_gpio[6] = {
 120              MOTDRV_HILO_ON(A, B),
 121              MOTDRV_HILO_ON(C, B),
 122              MOTDRV_HILO_ON(C, A),
 123              MOTDRV_HILO_ON(B, A),
 124              MOTDRV_HILO_ON(B, C),
 125              MOTDRV_HILO_ON(A, C)
 126          };
 127          
 128          
 129          #ifdef FEATURE_HYPERDRIVE
              // First 6 [0-5] are for falling BEMF, and last 6 [6-11] are for rising BEMF
              const U8 code hyperactive_gpio[12] = {
                  MOTDRV_HILOLO_ON(A, B, C),
                  MOTDRV_HILOLO_ON(C, B, A),
                  MOTDRV_HILOLO_ON(C, A, B),
                  MOTDRV_HILOLO_ON(B, A, C),
                  MOTDRV_HILOLO_ON(B, C, A),
                  MOTDRV_HILOLO_ON(A, C, B),
              
                  MOTDRV_HILOHI_ON(A, B, C),
                  MOTDRV_HILOHI_ON(C, B, A),
                  MOTDRV_HILOHI_ON(C, A, B),
                  MOTDRV_HILOHI_ON(B, A, C),
                  MOTDRV_HILOHI_ON(B, C, A),
                  MOTDRV_HILOHI_ON(A, C, B)
              };
              #endif
 147          
 148          SEG_IDATA U8      SLR_motor_state = MOTOR_STOPPED;
 149          // expected next commutation index value
 150          SEG_DATA  U8      commutation_index;
 151          
 152          // prepare skip register value in advance so at the end we need just
 153          // assignment code in order to minimize overhead.
 154          SEG_XDATA U8      pre_p0skip;
 155          SEG_XDATA U8      pre_p1skip;
 156          SEG_XDATA U8      pre_port1;
 157          
 158          // prev_zc_time, zc_time are time stamp of 32bit virtual timer to calculate
 159          // period of commutation.
 160          // prev_zc_time is used in startup function to find out initial commutation
 161          // time.
 162          SEG_DATA UU32     prev_zc_time;
 163          SEG_DATA UU32     zc_time;
 164          SEG_DATA UU32     zc_commutate_time;
 165          SEG_XDATA U32 zc_total_per_mech_rotation;
 166          
 167          // measuring commutation time (one electrical rotate)
 168          SEG_DATA UU32 time_per_rotate;
 169          // for fast phase reference.
 170          SEG_DATA U8       open_phase;
 171          
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 4   

 172          // timer for hyperdrive mode
 173          #ifdef FEATURE_HYPERDRIVE
              SEG_DATA U8       hyperdrive_speed;
              SEG_XDATA UU16    xhyp_speed;
              SEG_XDATA U16     hrem_time;
              #endif
 178          
 179          // calculated current motor running rpm
 180          SEG_XDATA U16     SLR_motor_current_rpm;
 181          #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
 182          // user requested (BY POT, PWM input or PC) target motor rpm.
 183          SEG_DATA U16      SLW_target_rpm;
 184          #endif
 185          
 186          // user requested (BY POT, PWM input or PC) target motor pwm.
 187          SEG_XDATA U16     SLW_target_pwm_duty;
 188          // current pwm duty cycle
 189          SEG_DATA U16      SLR_pwm_duty;
 190          // interval for pi calculation or POT(or PWM input) adc.
 191          // unit : 65536*(1/24.5M) = about 2.7ms.
 192          // value should be (2^n - 1), for fast process in interrupt routine.
 193          SEG_XDATA U8      pid_calc_interval;
 194          SEG_DATA U8       zc_count;
 195          #if BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
              SEG_XDATA U16     SLW_acceleration_step_size;
              SEG_XDATA U16     SLW_deceleration_step_size;
              #endif
 199          // BLDC motor numbe of poles. (must be even number)
 200          SEG_XDATA U8      num_poles;
 201          SEG_XDATA U8      zc_total_count;
 202          // time stamp when over current or stall happens.
 203          SEG_XDATA U16     error_event_time;
 204          // minimum duty cycle for startup and running.
 205          UU16 SLR_minimum_duty;
 206          U16  SLR_minimum_rpm;
 207          
 208          bit speed_updated;             // every electrical rotation will set this bit.
 209          bit SLW_user_direction;        // CW = 0, default. to avoid motor direction
 210          bit pid_flag = 0;              // time for pid calculation
 211          bit SLW_rpm_updated;           // status for application level.
 212          bit SLW_pwm_updated;           // status for application level.
 213          bit SLR_motor_stalled;
 214          bit last_motor_stalled;
 215          bit handle_motor_error;
 216          static bit rising_bemf;
 217          static bit motor_spinning;
 218          static bit motor_direction;    // CW = 0, default
 219          #ifdef FEATURE_PID_TUNE_FUNCTION
              extern bit tune_in_progress;
              #endif
 222          
 223          // OP amp bias voltage to be subtracted after measuring phase current.
 224          static SEG_XDATA U16    opamp_offset;
 225          SEG_XDATA U16 SLR_motor_current;
 226          
 227          // Additional motor current to accumulate to perform further averaging
 228          // Number of additional accumulation to improve result
 229          #define CURRENT_SHIFT_ACC   (4)
 230          #define CURRENT_ACC         (1 << CURRENT_SHIFT_ACC)
 231          static SEG_XDATA U32    accum_motor_current;
 232          static SEG_XDATA U8     accum_motor_current_count;
 233          static SEG_XDATA U8     average_motor_current_adc;
 234          
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 5   

 235          // number of oc debounce at register. 0x05
 236          SEG_XDATA U8 SLW_oc_debounce;
 237          // reg. 0x04. over current threshold.
 238          SEG_XDATA U8 SLW_current_limit;
 239          
 240          // To monitor stall condition by delta_V, Delta_I
 241          static SEG_XDATA U16    prev_rpm;
 242          static SEG_XDATA U16    prev_I;
 243          static SEG_XDATA U8     stall_check_count;
 244          
 245          #ifdef FEATURE_MEAS_VMDC
 246          SEG_XDATA U16 SLR_motor_voltage;
 247          #endif
 248          
 249          SEG_XDATA U16 SLW_motor_max_rpm;
 250          
 251          
 252          static void MTR_process_adc(void);
 253          static void MTR_process_errors(void);
 254          
 255          //-----------------------------------------------------------------------------
 256          // Function Prototypes
 257          //-----------------------------------------------------------------------------
 258          
 259          //-----------------------------------------------------------------------------
 260          // SL_MTR_init
 261          //-----------------------------------------------------------------------------
 262          //
 263          // Return Value : None
 264          // Parameters   : None
 265          //
 266          //-----------------------------------------------------------------------------
 267          void SL_MTR_init(void)
 268          {
 269   1              COMP_initialize_comp();
 270   1          PCA0L = 0;
 271   1          PCA0H = 0;
 272   1          // start PWM
 273   1          PCA_enable_pwm();
 274   1          PCA0CN0_CR = 1;
 275   1          TMR2CN0_TR2 = 1;
 276   1          pid_calc_interval = DEFAULT_PID_INTERVAL;
 277   1          motor_spinning = 0;
 278   1          // To avoid garbage value, SLR_minimum_duty will be calculated in smart way.
 279   1          // However, if user stopped motor by reset_pin and started it immediately,
 280   1          // there is no chance to calculate SLR_minimum_duty because code will
 281   1          // skip the MTR_start_spinning().
 282   1          SLR_minimum_duty.U16 = (MAX_USER_PWM_VALUE>>2);
 283   1          handle_motor_error = 0;
 284   1          SLW_user_direction = motor_direction = 0;
 285   1          SLR_motor_state = MOTOR_STOPPED;
 286   1          SLR_motor_current_rpm = 0;
 287   1          // updated and calculated SLR_minimum_rpm at SL_MTR_change_num_poles()
 288   1          //num_poles = BLDC_RD_NUM_POLES;
 289   1          //SLR_minimum_rpm = (U16)((60UL*1.2*2*SYSCLK)/(65536*2*6*SPEED_UNIT))/num_poles;
 290   1      #ifndef BUILD_FOR_PROTOCOL
                  SLW_oc_debounce = MOTOR_OC_MAX_DEBOUNCE;
                  SLW_current_limit = MOTOR_OC;
                  SLW_motor_max_rpm = MOTOR_MAX_RPM;
              #endif
 295   1      
 296   1      }
 297          
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 6   

 298          
 299          //-----------------------------------------------------------------------------
 300          // SL_MTR_motor
 301          //-----------------------------------------------------------------------------
 302          //
 303          // Return Value : None
 304          // Parameters   : None
 305          //
 306          // Description  :
 307          //      This function should be called regularly at application level.
 308          //
 309          //-----------------------------------------------------------------------------
 310          void SL_MTR_motor(void)
 311          {
 312   1          MTR_process_errors();
 313   1          MTR_process_adc();
 314   1          if( MOTOR_STOPPED == SLR_motor_state)
 315   1          {
 316   2              // Initialize variables while in stopped state
 317   2              accum_motor_current_count = CURRENT_ACC;
 318   2              accum_motor_current = 0;
 319   2              average_motor_current_adc = 0;
 320   2              SLR_motor_current = 0;
 321   2          }
 322   1          else if( MOTOR_RUNNING == SLR_motor_state)
 323   1          {
 324   2              MTR_calculate_motor_rpm();
 325   2      
 326   2      #ifndef FEATURE_PID_TUNE_FUNCTION
 327   2              MTR_calculate_pid();
 328   2      #endif
 329   2              // SL_MTR_stop_motor() will change state
 330   2          }
 331   1      
 332   1          // Clear the adc_flags for current and vmotor
 333   1          adc_flags &= ~( (0x01<<ADC_MUX_CURRENT)
 334   1      #ifdef FEATURE_MEAS_VMDC
 335   1                  | (0x01 << ADC_MUX_VMOTOR)
 336   1      #endif
 337   1              );
 338   1      }
 339          
 340          //-----------------------------------------------------------------------------
 341          // SL_MTR_start_motor
 342          //-----------------------------------------------------------------------------
 343          //
 344          // Return Value : None
 345          // Parameters   : None
 346          //
 347          // Description  :
 348          //      Application level would call this to start motor.
 349          //      If motor is not in state MOTOR_STOPPED, it will just return.
 350          //      It will check motor spinning status for fast startup and if there is
 351          //      enough BEMF found, it skips the blind spinning stage.
 352          //      After staring motor, SLR_motor_state would be MOTOR_RUNNING.
 353          //-----------------------------------------------------------------------------
 354          void SL_MTR_start_motor(void)
 355          {
 356   1          if ((MOTOR_STOPPED != SLR_motor_state) || SLR_motor_stalled )
 357   1          {
 358   2              return;
 359   2          }
 360   1          // respect user selected direction
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 7   

 361   1          MTR_set_direction(SLW_user_direction);
 362   1          MTR_check_motor_spinning();
 363   1          if(!motor_spinning)
 364   1          {
 365   2              MTR_start_spinning();
 366   2          }
 367   1          MTR_do_quickstart();
 368   1      
 369   1          // Initial stall condition has been checked in the MTR_do_quickstart().
 370   1          // Initial startup - take a longer time to check for potential stall
 371   1          stall_check_count = 255;
 372   1          last_motor_stalled = 0;
 373   1          handle_motor_error = 0;
 374   1      
 375   1          // change status to running mode
 376   1          SLR_motor_state = MOTOR_RUNNING;
 377   1      }
 378          
 379          
 380          //-----------------------------------------------------------------------------
 381          // SL_MTR_stop_motor
 382          //-----------------------------------------------------------------------------
 383          //
 384          // Return Value : None
 385          // Parameters   : None
 386          //
 387          // Description  :
 388          //  Stop running motor and de-energize phases only when SLR_motor_state is
 389          //  MOTOR_RUNNING, otherwise it will just return.
 390          //  After stopping motor, disable FG signal(TP308) and prepare comparator
 391          //  to detect BEMF for fast restart.
 392          //  Following variables will be
 393          //  SLR_motor_state = MOTOR_STOPPED.
 394          //  SLR_motor_current_rpm = 0
 395          //  SLR_rpm_updated = 1
 396          //-----------------------------------------------------------------------------
 397          void SL_MTR_stop_motor(void)
 398          {
 399   1          bit saved_ea;
 400   1      
 401   1          // disable timer0 interrupt
 402   1          IE_ET0 = 0;
 403   1          // disable CPT0 interrupt
 404   1          EIE1 &= ~0x20;
 405   1          if(MOTOR_RUNNING != SLR_motor_state)
 406   1          {
 407   2              return;
 408   2          }
 409   1          // PCA, timer2 will be running continuously.
 410   1          // default pin status.
 411   1          // keep P1.0, P1.1 latch status
 412   1          MTR_ATOMIC_ACCESS_START();
 413   1          P1 = ((P1 & ~MOTDRV_ALL_MASK) | MOTDRV_ALL_OFF) | ~MOTDRV_ALL_MASK;
 414   1          P1SKIP |= MOTDRV_ALL_MASK;
 415   1          MTR_ATOMIC_ACCESS_END();
 416   1          // stop timer 3 and clear flag
 417   1          TMR3CN0 &= ~0x84;
 418   1      
 419   1          // keep tracking one phase of bemf
 420   1          CMP1MX = (CPMUX_Y << 4) | CPMUX_A;
 421   1      
 422   1          SLR_motor_state = MOTOR_STOPPED;
 423   1          SLR_motor_current_rpm = 0;
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 8   

 424   1          SLW_rpm_updated = 1;                // for apps level status.
 425   1          SLR_pwm_duty = SLR_minimum_duty.U16;
 426   1          PCA_change_duty_cycle(SLR_pwm_duty);
 427   1      }
 428          
 429          //-----------------------------------------------------------------------------
 430          // MTR_check_motor_spinning
 431          //-----------------------------------------------------------------------------
 432          //
 433          // Return Value : None
 434          // Parameters   : None
 435          //
 436          // Description:
 437          //  Check motor running and direction status before alignment.
 438          //  This should be called just before MTR_start_spinning & MTR_do_quickstart.
 439          //-----------------------------------------------------------------------------
 440          void MTR_check_motor_spinning(void)
 441          {
 442   1          U8 t1, t2;       // t1: old, t2: new
 443   1          U8 gap;
 444   1          bit rising_zc_done, cptout;
 445   1      
 446   1      
 447   1          CMP1CN0 = 0x8F;      // 20mV Hysteresis
 448   1          // clear flags
 449   1          CMP1CN0 &= ~0x30;
 450   1          // set P0.0~P0.3 to pure analog pins because we need to bemf to determine
 451   1          // current motor rotation using comparator.
 452   1          P0MDIN &= ~FILTERED_ALLPINS_MASK;
 453   1          t1 = (U8)SL_MTR_time();
 454   1          t2 = t1;
 455   1          motor_spinning = 0;
 456   1          rising_zc_done = 0;
 457   1          do
 458   1          {
 459   2              t2 = (U8)SL_MTR_time();
 460   2              gap = t2 - t1;
 461   2              // rising zc found ?
 462   2              if( (0 == rising_zc_done) && (CMP1CN0 & 0x20) )
 463   2              {
 464   3                  t1 = t2;
 465   3                  rising_zc_done = 1;
 466   3                  CMP1CN0 &= ~0x30;
 467   3              }
 468   2              // falling zc found ?
 469   2              else if( (1 == rising_zc_done) && (CMP1CN0 & 0x10) )
 470   2              {
 471   3                  goto check_direction;
 472   3              }
 473   2          } while(gap < VALID_TIME_FOR_QUICK_START);
 474   1          // No BEMF or too low.
 475   1          goto exit_check_spinning;
 476   1      
 477   1      check_direction:
 478   1          // CP0- = C, CP0+ = B
 479   1          // B>C ==> 1(CCW), B<C ==> 0(CW)
 480   1          CMP0MX = (CPMUX_C << 4) | (CPMUX_B);
 481   1          // cmp = (B>C)?1:0; B>C ==>CCW(1), B<C ==>CW(0)
 482   1          // just considering comparator response time.
 483   1          t1 = 0;
 484   1          while(--t1);
 485   1          cptout = ((CMP1CN0 & 0x40) == 0x40);
 486   1          if( cptout == motor_direction)
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 9   

 487   1          {
 488   2              motor_spinning = 1;
 489   2          }
 490   1          else
 491   1          {
 492   2              motor_spinning = 0;
 493   2          }
 494   1      exit_check_spinning:
 495   1          CMP1CN0 = 0x80;      // 0mV Hysteresis
 496   1          P0MDIN |= FILTERED_ALLPINS_MASK;     // set P0.0~P0.3 to digital pins
 497   1      }
 498          
 499          #if (BLDC_RD_PWM_METHOD == H_BRIDGE_HIGH_SIDE_PWM) || \
 500              (BLDC_RD_PWM_METHOD == H_BRIDGE_LOW_SIDE_PWM) || \
 501              (BLDC_RD_PWM_METHOD == H_BRIDGE_MIXED_MODE_PWM)
 502          //-----------------------------------------------------------------------------
 503          // MTR_pre_commutation
 504          //-----------------------------------------------------------------------------
 505          //
 506          // Return Value : None
 507          // Parameters   : None
 508          //
 509          // To minimize overhead in timer 0 interrupt routine, prepare all skip/port
 510          // registers before needing.
 511          //-----------------------------------------------------------------------------
 512          void MTR_pre_commutation(void)
 513          {
 514   1          pre_port1 = active_gpio[commutation_index];
 515   1      #if BLDC_RD_PWM_METHOD == H_BRIDGE_MIXED_MODE_PWM
 516   1          pre_p1skip = skipPattern[rising_bemf][commutation_index];
 517   1      #else
                  pre_p1skip = skipPattern[commutation_index];
              #endif
 520   1          if (rising_bemf)
 521   1          {
 522   2              // rising_bemf is the current state - we need to prepare for the new
 523   2              // state where BEMF is falling
 524   2      
 525   2              pre_p0skip = DEFAULT_P0SKIP ^ VIRTUAL_NEUTRAL;
 526   2          }
 527   1          else
 528   1          {
 529   2              pre_p0skip = DEFAULT_P0SKIP ^ freeterminal[commutation_index];
 530   2          }
 531   1      }
 532          
 533          #ifdef FEATURE_HYPERDRIVE
              //-----------------------------------------------------------------------------
              // MTR_hyper_commutate
              //-----------------------------------------------------------------------------
              //
              // Return Value : None
              // Parameters   : None
              //
              // This is to commutate to hyper drive mode.
              //-----------------------------------------------------------------------------
              void MTR_hyper_commutate(void)
              {
                  if (rising_bemf)
                  {
                      P1 = (P1 & ~MOTDRV_ALL_MASK) | hyperactive_gpio[open_phase+6];
                  }
                  else
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 10  

                  {
                      P1 = (P1 & ~MOTDRV_ALL_MASK) | hyperactive_gpio[open_phase];
                  }
              }
              #endif
 555          
 556          //-----------------------------------------------------------------------------
 557          // MTR_commutate
 558          //-----------------------------------------------------------------------------
 559          //
 560          // Return Value : None
 561          // Parameters   : None
 562          //
 563          // This is to commutate next phase.
 564          // open_phase is to refer to current open phase in order to make simple life
 565          // when it need. If use commutation_index, we should refer to motor_direction
 566          // bit as well to know current open phase.
 567          //-----------------------------------------------------------------------------
 568          void MTR_commutate(void)
 569          {
 570   1          // don't disable cross bar. if disable it, other peripherals would be
 571   1          // disabled such as UART.
 572   1      
 573   1          pre_port1 |= (P1 & ~MOTDRV_ALL_MASK);
 574   1          // keep latch of P1.0,P1.1
 575   1          P1 = pre_port1 | ~MOTDRV_ALL_MASK;
 576   1          P0SKIP = pre_p0skip;
 577   1          P1SKIP = pre_p1skip;
 578   1          // open_phase = commutation_index
 579   1          open_phase = commutation_index;
 580   1      
 581   1          if (0 == motor_direction)
 582   1          {
 583   2              commutation_index ++;
 584   2              if( commutation_index > 5)
 585   2                  commutation_index = 0;
 586   2          }
 587   1          // CCW
 588   1          else
 589   1          {
 590   2              commutation_index--;
 591   2              if( commutation_index > 5)
 592   2                  commutation_index = 5;
 593   2          }
 594   1      }
 595          #endif
 596          
 597          
 598          //-----------------------------------------------------------------------------
 599          // MTR_start_spinning
 600          //-----------------------------------------------------------------------------
 601          //
 602          // Return Value : None
 603          // Parameters   : None
 604          //
 605          // Alignment and blind spinning.
 606          // At the end, this will de-energize all phases to spin freely.
 607          // This function has used comparator clear function in PCA.
 608          // In order to cut current as expected, comparator has to have fastest response.
 609          // Small delay in response make significant current surge. (a few us delay is
 610          // pretty significant in 24kHz(42us period) PWM frequency)
 611          // Please refer to application note for more details.
 612          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 11  

 613          void MTR_start_spinning(void)
 614          {
 615   1          U8 idx, tmp;
 616   1          bit saved_ea;
 617   1          U32 SEG_XDATA SIG_k_1;    // sum(n=0,...,K-1)
 618   1          U32 SEG_XDATA SIG_k;      // sum(n=0,...,K)
 619   1          U16 T_k;                  // T_k
 620   1      
 621   1          // set initial polarity before staring.
 622   1          PCA_set_initial_polarity();
 623   1      
 624   1          zc_time.U32 = 0L;
 625   1          prev_zc_time.U32 = 0L;
 626   1      
 627   1          CMP0MD = 0x00;                  // fastest response time of comparator.
 628   1      
 629   1          SIG_k = 0L;
 630   1      
 631   1          // configure comparator 0 input pins
 632   1          // If I_MEAS > LDO(1.8V), comparator output is low.
 633   1          CMP0MX = (CPT0MX_IMEASURE<<4) | CPT0MX_LDO;
 634   1      
 635   1          // settling time
 636   1          TMR_delay_timer3(1);
 637   1      
 638   1          // 50% of duty cycle.
 639   1          SLR_pwm_duty = (MAX_USER_PWM_VALUE>>1);
 640   1          PCA_change_duty_cycle(SLR_pwm_duty);
 641   1      
 642   1          // start comparator clear function
 643   1          PCA0CLR = (1<<MOTPWM_CHANNEL);
 644   1      
 645   1          // Initial commutation
 646   1          commutation_index = 0;
 647   1          rising_bemf = 0;
 648   1      
 649   1          // alignment
 650   1          MTR_ATOMIC_ACCESS_START();
 651   1          MTR_pre_commutation();
 652   1          MTR_commutate();
 653   1          MTR_ATOMIC_ACCESS_END();
 654   1          tmp = LOCKING_TIME_FOR_ALIGNMENT;
 655   1          while(--tmp > 0)
 656   1          {
 657   2              TMR_delay_timer3(3);
 658   2          }
 659   1      
 660   1          // blind spinning, increase speed linearly. - refer to AN
 661   1          commutation_index = 0;
 662   1          idx = 0;
 663   1          do
 664   1          {
 665   2              // commutation
 666   2              MTR_ATOMIC_ACCESS_START();
 667   2              MTR_pre_commutation();
 668   2              MTR_commutate();
 669   2              MTR_ATOMIC_ACCESS_END();
 670   2      
 671   2              if( idx < NO_OF_STARTUP_DELAY)
 672   2              {
 673   3                  T_k = start_delay[idx++];
 674   3              }
 675   2              else
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 12  

 676   2              {
 677   3                  // calculate next commutation time. approximately calculated
 678   3                  // to avoid using sqrt() function.
 679   3                  // calculate T[k+1]
 680   3                  T_k = SIG_k_1*T_k/SIG_k;
 681   3              }
 682   2              SIG_k_1 = SIG_k;
 683   2              SIG_k += T_k;
 684   2      
 685   2              TMR3RL = -T_k;
 686   2              TMR3 = TMR3RL;
 687   2              TMR3CN0 &= ~0x80;
 688   2              // Start Timer 3
 689   2              TMR3CN0 = 0x04;
 690   2              //prev_acc_time = acc_time;
 691   2              tmp = 0;
 692   2              CMP1CN0 &= ~0x30;
 693   2              while(tmp < REPEATED_NUM_OF_TIMER_FOR_STARTUP)
 694   2              {
 695   3                  if( TMR3CN0 & 0x80 )
 696   3                  {
 697   4                      TMR3CN0 &= ~0x80;
 698   4                      tmp++;
 699   4                  }
 700   3                  if((CMP1CN0 & 0x10) == 0x10)
 701   3                  {
 702   4                      CMP1CN0 &= ~0x10;
 703   4                      MTR_ATOMIC_ACCESS_START();
 704   4                      SLR_minimum_duty.U8[LSB] = PCA0L;
 705   4                      SLR_minimum_duty.U8[MSB] = PCA0H;
 706   4                      MTR_ATOMIC_ACCESS_END();
 707   4                  }
 708   3              }
 709   2              // Stop Timer 3
 710   2              TMR3CN0 &= ~0x04;
 711   2              if (T_k < LAST_DELAY_LIMIT)
 712   2              {
 713   3                  break;
 714   3              }
 715   2          } while(1);
 716   1      
 717   1          SLR_minimum_duty.U16 = SLR_minimum_duty.U16<<(16-PWM_RESOLUTION);
 718   1          SLR_minimum_duty.U16 -= 32768;
 719   1          if(SLR_minimum_duty.U16 >= 32768)
 720   1          {
 721   2              SLR_minimum_duty.U16 = 0x7FFF;
 722   2          }
 723   1          SLR_pwm_duty =  SLR_minimum_duty.U16;
 724   1      
 725   1          // disable comparator clear function and disconnect all signals.
 726   1          CMP0MX = 0xFF;              // default ..
 727   1          PCA0CLR = 0;
 728   1      
 729   1          // stop energizing and let motor run freely to detect BEMF
 730   1          P1 = ((P1 & ~MOTDRV_ALL_MASK) | MOTDRV_ALL_OFF) | ~MOTDRV_ALL_MASK;
 731   1          P1SKIP |= MOTDRV_ALL_MASK;
 732   1      }
 733          
 734          //-----------------------------------------------------------------------------
 735          // MTR_do_quickstart
 736          //-----------------------------------------------------------------------------
 737          //
 738          // Return Value : None
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 13  

 739          // Parameters   : None
 740          //
 741          // Description:
 742          //      Assumed that motor already running freely with enough bemf.
 743          //      To Detect rising and falling edge of bemf and calculate next
 744          //      expected commutation time and appropriate commutation index.
 745          //-----------------------------------------------------------------------------
 746          void MTR_do_quickstart(void)
 747          {
 748   1          bit saved_ea, is_1st_crossing;
 749   1          UU32 ticks;
 750   1      
 751   1          // -----------------------------------------------------------------------
 752   1          // start investigating of zero crossing
 753   1      
 754   1          // Make filtered pins analog - we do not need the blanking signal
 755   1          P0MDIN &= ~FILTERED_ALLPINS_MASK;
 756   1      
 757   1          // select PHASE A rising and falling edge to determine next expected
 758   1          // commutation index and time based on selected spin direction.
 759   1          CMP0MX = (CPMUX_Y << 4) | CPMUX_A;
 760   1          // 1ms is more than enough for comparator settling time.
 761   1          TMR_delay_timer3(1);
 762   1          // clear comparator flags
 763   1          CMP1CN0 &= ~0x30;
 764   1      
 765   1          // wait max 32 ms loop.
 766   1          TMR3RL = 0;
 767   1          TMR3 = (U16)0;
 768   1          // Start Timer 3
 769   1          TMR3CN0 = 0x04;
 770   1      
 771   1          // prev_zc_time.U16[LSB] : used to record zero crossing event at startup
 772   1          // to save ram usage.
 773   1          prev_zc_time.U16[LSB] = 0;
 774   1          is_1st_crossing = 1;
 775   1          while( !(TMR3CN0 & 0x80) )
 776   1          {
 777   2              if (CMP1CN0 & 0x30)
 778   2              {
 779   3                  // This is the first event
 780   3                  if ( is_1st_crossing )
 781   3                  {
 782   4                      // stop timer 3 and restart to record next event.
 783   4                      MTR_ATOMIC_ACCESS_START();
 784   4                      TMR3CN0 &= ~0x04;
 785   4                      TMR3 = (U16)0;
 786   4                      TMR3CN0 = 0x04;
 787   4                      MTR_ATOMIC_ACCESS_END();
 788   4                  }
 789   3                  else
 790   3                  {
 791   4                      // second event, get the time period.
 792   4                      MTR_ATOMIC_ACCESS_START();
 793   4                      TMR3CN0 &= ~0x04;
 794   4                      prev_zc_time.U16[LSB] = TMR3;
 795   4                      // to measure offset (overhead)
 796   4                      TMR3 = 0;
 797   4                      TMR3CN0 = 0x04;
 798   4                      MTR_ATOMIC_ACCESS_END();
 799   4                  }
 800   3      
 801   3      
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 14  

 802   3                  // BEMF Falling, comparator output Falling edge
 803   3                  if (CMP1CN0 & 0x10)
 804   3                  {
 805   4                      // CW
 806   4                      if( 0 == motor_direction)
 807   4                      {
 808   5                          open_phase = 1;         // current open phase
 809   5                          commutation_index = 2;  // next commutation index
 810   5                      }
 811   4                      // CCW
 812   4                      else
 813   4                      {
 814   5                          open_phase = 4;         // current open phase
 815   5                          commutation_index = 3;  // next commutation index
 816   5                      }
 817   4                      rising_bemf = 0;
 818   4                  }
 819   3                  // BEMF rising, comparator output rising edge
 820   3                  else if(CMP1CN0 & 0x20)
 821   3                  {
 822   4                      // CW
 823   4                      if( 0 == motor_direction)
 824   4                      {
 825   5                          open_phase = 4;         // current open phase
 826   5                          commutation_index = 5;  // next commutation index
 827   5                      }
 828   4                      // CCW
 829   4                      else
 830   4                      {
 831   5                          open_phase = 1;         // current open phase
 832   5                          commutation_index = 0;  // next commutation index
 833   5                      }
 834   4                      rising_bemf = 1;
 835   4                  }
 836   3                  // clear flags
 837   3                  CMP1CN0 &= ~0x30;
 838   3      
 839   3                  if( is_1st_crossing )
 840   3                  {
 841   4                      is_1st_crossing = 0;
 842   4                  }
 843   3                  else
 844   3                  {
 845   4                      break;
 846   4                  }
 847   3              }
 848   2          }
 849   1          // if motor stalled, do not energize it.
 850   1          if(TMR3CN0 & 0x80)
 851   1          {
 852   2              SLR_motor_stalled = 1;
 853   2              return;
 854   2          }
 855   1          SLR_motor_stalled = 0;
 856   1      
 857   1          // calculate next expected commutation time from current zero-crossing.
 858   1          // ticks is time from rising to falling zero-crossing time of phase A.
 859   1          // That is time for 180 deg.
 860   1          // Desired period for 30 deg is:
 861   1          // period = prev_zc_time.U16[LSB]*TIMER3_PRESCALER(=12)/6
 862   1          //ticks.U32 = (U32)TIMER3_PRESCALER * prev_zc_time.U16[LSB] / 6;
 863   1          // This is for 30deg rotate(zero-crossing to commutation)
 864   1          ticks.U32 = 2UL * prev_zc_time.U16[LSB];
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 15  

 865   1      
 866   1          // zc_commutate_time is a period between zero crossing.
 867   1          // NOTE : need to initialize zc_commute_time, zc_time, pre_zc_time
 868   1          // to do exponential filtering in the comparator interrupt routine.
 869   1          MTR_save_zero_crossing_time();
 870   1          zc_commutate_time.U32 = 2UL * ticks.U32;
 871   1      
 872   1          MTR_ATOMIC_ACCESS_START();
 873   1          // Stop Timer 3(DIV_12) and compensate overhead
 874   1          TMR3CN0 &= ~0x04;
 875   1          ticks.U32 -= ((U32)TIMER3_PRESCALER * TMR3);
 876   1          repeated_timer0 = 0;
 877   1          timer0_next.U16 = -ticks.U16[LSB];
 878   1      
 879   1          TCON_TR0 = 0;
 880   1          TL0 = timer0_next.U8[LSB];
 881   1          TH0 = timer0_next.U8[MSB];
 882   1          // start timer 0 as soon as possible
 883   1          TCON_TR0 = 1;
 884   1          TCON_TF0 = 0;
 885   1          MTR_ATOMIC_ACCESS_END();
 886   1      
 887   1          // zero crossing detected. next event is TIMER0_COMMUTATION.
 888   1          // Prepare skip register and timer0_state value.
 889   1          MTR_pre_commutation();
 890   1          timer0_state = TIMER0_COMMUTATION;
 891   1          zc_total_count = (num_poles >> 1) * 6;
 892   1          zc_count = zc_total_count;
 893   1      
 894   1          // just in case, disable comparator interrupt
 895   1          CMP1CN0 &= ~0x30;
 896   1          CMP0MD &= ~0x30;
 897   1      
 898   1          SET_TIMER0_HIGH_PRIORITY();
 899   1          // enable timer0 interrupt
 900   1          IE_ET0 = 1;
 901   1          // enable comparator0 interrupt.
 902   1          // now comparator interrupt enabled/disabled by CMP0MD.
 903   1          EIE1 |= 0x20;
 904   1      
 905   1          // for initial rpm calculation
 906   1          // at this moment, atomic access not required (motor not under running)
 907   1          // for time_per_rotate
 908   1          // to avoid current surge by big jump in pwm_duty.
 909   1          SLR_motor_current_rpm = (U32)(60UL*SYSCLK*2/6/SPEED_UNIT)/((U32)num_poles*zc_commutate_time.U32);
 910   1          speed_updated = 0;
 911   1          SLW_rpm_updated = 0;
 912   1          time_per_rotate.U32 = 0UL;
 913   1          zc_total_per_mech_rotation = 0UL;
 914   1          // initiate pwm filtering according to rising/falling bemf.
 915   1          SLW_pwm_updated = 0;
 916   1          PCA_change_duty_cycle(SLR_pwm_duty);
 917   1      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
 918   1          // initialize PID variables.
 919   1          MTR_pid_init();
 920   1      #endif
 921   1      }
 922          
 923          //-----------------------------------------------------------------------------
 924          // MTR_calculate_motor_rpm
 925          //-----------------------------------------------------------------------------
 926          //
 927          // Return Value : None
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 16  

 928          // Parameters   : None
 929          //
 930          // Description:
 931          //      This function should be called regularly.
 932          //      Speed would be updated after one mechanical rotation.
 933          //      This will set the SLW_rpm_updated variable for application level.
 934          //-----------------------------------------------------------------------------
 935          void MTR_calculate_motor_rpm(void)
 936          {
 937   1          SEG_XDATA U32 t0;
 938   1          bit saved_ea;
 939   1      
 940   1          // -----------------------------------------------------------------------
 941   1          // calculate current rpm based on at least 1 mechanical rotation
 942   1          // rpm = 60 / (ttr * PAIR_OF_POLES * 6)
 943   1          if (speed_updated)
 944   1          {
 945   2              speed_updated = 0;
 946   2              MTR_ATOMIC_ACCESS_START();
 947   2              t0 = zc_total_per_mech_rotation;
 948   2              MTR_ATOMIC_ACCESS_END();
 949   2              SLR_motor_current_rpm = (U16)((SYSCLK*60/SPEED_UNIT)/t0);
 950   2              // status for application level
 951   2              SLW_rpm_updated = 1;
 952   2          }
 953   1      }
 954          
 955          
 956          //-----------------------------------------------------------------------------
 957          // MTR_save_zero_crossing_time
 958          //-----------------------------------------------------------------------------
 959          //
 960          // Return Value : None
 961          // Parameters   : None
 962          //
 963          //  This function should be called in the interrupt routine or
 964          //  It should be protected by MTR_ATOMIC_ACCESS_START() MTR_ATOMIC_ACCESS_END()
 965          //-----------------------------------------------------------------------------
 966          void MTR_save_zero_crossing_time(void)
 967          {
 968   1          static U8 ovf;
 969   1      
 970   1          prev_zc_time.U32 = zc_time.U32;
 971   1          IE_EA = 0;
 972   1          zc_time.UU16[LSB].U8[LSB] = PCA0L;
 973   1          zc_time.UU16[LSB].U8[MSB] = PCA0H;
 974   1          ovf = PCA0CN0_CF;
 975   1          zc_time.U16[MSB] = user_timer;
 976   1          IE_EA = 1;
 977   1      
 978   1          if (ovf && ( (zc_time.UU16[LSB].U8[MSB] & 0x80) == 0 ) )
 979   1          {
 980   2              zc_time.U16[MSB]++;
 981   2          }
 982   1      }
 983          
 984          //-----------------------------------------------------------------------------
 985          // MTR_calculate_pid
 986          //-----------------------------------------------------------------------------
 987          //
 988          // Return Value : None
 989          // Parameters   : None
 990          //
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 17  

 991          // Description:
 992          //      If BLDC_RD_RPM_OR_PWM is PWM_PARAMETER,
 993          //      - target speed controlled by SLW_target_pwm_duty variables.
 994          //      If BLDC_RD_RPM_OR_PWM is RPM_PARAMETER,
 995          //      - target speed controlled by SLW_target_rpm variables.
 996          //-----------------------------------------------------------------------------
 997          void MTR_calculate_pid(void)
 998          {
 999   1      #ifdef FEATURE_HYPERDRIVE
                  U16 scaled_pwm;
                  U16 xspeed;
              #endif
1003   1      
1004   1      #if BLDC_RD_RPM_OR_PWM == RPM_PARAMETER
1005   1          // MTR_pid_compute_newpwm() should be called regularly. This function
1006   1          // has PT_YIELD(due to pretty high cpu load to calculate it) and
1007   1          // will clear pid_flag.
1008   1          SLR_pwm_duty = MTR_pid_compute_newpwm();
1009   1      
1010   1      #elif BLDC_RD_RPM_OR_PWM == PWM_PARAMETER
                  U16 pwmnew;
              
                  if(!pid_flag)
                  {
                      return;
                  }
                  pid_flag = 0;
              
                  // emulated pid function.
                  if( SLW_target_pwm_duty > SLR_pwm_duty)
                  {
                      pwmnew = SLR_pwm_duty + SLW_acceleration_step_size;
                      if(pwmnew < SLR_pwm_duty)
                      {
                          // This is to handle overflow across 0xffff-0x0000 boundary
                          pwmnew = MAX_USER_PWM_VALUE;
                      }
                      SLR_pwm_duty = pwmnew;
                  }
                  else if(SLW_target_pwm_duty < SLR_pwm_duty)
                  {
                      pwmnew = SLR_pwm_duty - SLW_deceleration_step_size;
                      if(pwmnew < SLR_minimum_duty.U16)
                      {
                          // Protect against PWM duty cycle dropping below startup value
                          pwmnew = SLR_minimum_duty.U16;
                      }
                      SLR_pwm_duty = pwmnew;
                  }
                  pid_done = 1;
              #endif
1042   1      
1043   1      #ifdef FEATURE_HYPERDRIVE
              
                  if (pid_done)
                  {
                      // Scale up by 10% - we want to reserve the remainder for hyperdrive mode
                      scaled_pwm = ((U32)(PWM_SCALE_FACTOR * 65536.0) * SLR_pwm_duty) >> 16;
                      if (scaled_pwm < SLR_pwm_duty)
                      {
                          // This is to handle overflow across 0xffff-0x0000 boundary
                          scaled_pwm = MAX_USER_PWM_VALUE;
                      }
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 18  

              
                      // Hyperdrive will start working when scaled_pwm is 100%,
                      // or SLR_pwm_duty > (65536.0/PWM_SCALE_FACTOR).
                      if ( (scaled_pwm ^ MAX_USER_PWM_VALUE) == 0 )
                      {
                          // Obtain hyperdrive timing based on fraction of 256
                          // larger number implies faster speed [0-3]
                          xspeed = ((U16)(SLR_pwm_duty - (U16)(65536.0/PWM_SCALE_FACTOR)) * HYPERDRIVE_FACTOR) >> HYPER_
             -SHIFT;
                          if (xhyp_speed.U16 > xspeed)
                          {
                              xhyp_speed.U16--;
                          }
                          else if (xhyp_speed.U16 < xspeed)
                          {
                              xhyp_speed.U16++;
                          }
                      }
                      else
                      {
                          xhyp_speed.U16 = 0;
                      }
                      hyperdrive_speed = xhyp_speed.U16 >> (8-HYPER_SHIFT);
                      pid_done = 0;
                  }
                  else
                  {
                      scaled_pwm = SLR_pwm_duty;
                  }
                  PCA_change_duty_cycle(scaled_pwm);
              #else
1084   1          PCA_change_duty_cycle(SLR_pwm_duty);
1085   1      #endif
1086   1      }
1087          
1088          
1089          //-----------------------------------------------------------------------------
1090          // SL_MTR_time
1091          //-----------------------------------------------------------------------------
1092          //
1093          // Return Value : xtime
1094          //      high 16bit of virtual 32bit timer.
1095          //      time unit would be 2.7ms.
1096          // Parameters   : None
1097          //
1098          // Description:
1099          //
1100          //      Get the high 16 bit of virtual 32bit timer.
1101          //-----------------------------------------------------------------------------
1102          U16 SL_MTR_time(void)
1103          {
1104   1          bit saved_ea;
1105   1          U16 xtime;
1106   1      
1107   1          MTR_ATOMIC_ACCESS_START();
1108   1          xtime = user_timer;
1109   1          MTR_ATOMIC_ACCESS_END();
1110   1      
1111   1          return xtime;
1112   1      }
1113          
1114          //-----------------------------------------------------------------------------
1115          // SL_MTR_change_num_poles
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 19  

1116          //-----------------------------------------------------------------------------
1117          //
1118          // Return Value : None
1119          // Parameters   :
1120          //      (U8) poles : number of poles. It must be even number
1121          // Description:
1122          //      This function should be called at least one time to calculate
1123          //      SLR_minimum_rpm.
1124          //-----------------------------------------------------------------------------
1125          void SL_MTR_change_num_poles(U8 poles)
1126          {
1127   1          num_poles = poles;
1128   1          // 1.2 is just head room.
1129   1          SLR_minimum_rpm = (U16)((60UL*1.2*2*SYSCLK)/(65536*2*6*SPEED_UNIT))/num_poles;
1130   1      }
1131          
1132          //-----------------------------------------------------------------------------
1133          // MTR_process_adc
1134          //-----------------------------------------------------------------------------
1135          //
1136          // Return Value : None
1137          // Parameters   : None
1138          // Description: Process ADC results and perform filtering or offset adjustment
1139          //
1140          //-----------------------------------------------------------------------------
1141          static void MTR_process_adc(void)
1142          {
1143   1          static SEG_XDATA U16 prev_opamp_offset = 0;
1144   1          UU16 SEG_XDATA tmp;
1145   1      
1146   1          if ( adc_flags & (0x01<<ADC_MUX_CURRENT) )
1147   1          {
1148   2              // get latest saved phase current in the array
1149   2              tmp.U16 = adc_result[ADC_MUX_CURRENT];
1150   2      
1151   2              // read op amp bias voltage for future current calculation.
1152   2              if( MOTOR_STOPPED == SLR_motor_state )
1153   2              {
1154   3                  opamp_offset = adc_result[ADC_MUX_CURRENT];
1155   3                  opamp_offset = (prev_opamp_offset>>1) + \
1156   3                                 ((prev_opamp_offset+opamp_offset)>>2);
1157   3                  prev_opamp_offset = opamp_offset;
1158   3              }
1159   2              else
1160   2              {
1161   3                  if( opamp_offset > tmp.U16)
1162   3                  {
1163   4                      tmp.U16 = 0;
1164   4                  }
1165   3                  else
1166   3                  {
1167   4                      tmp.U16 -= opamp_offset;
1168   4                  }
1169   3      
1170   3                  accum_motor_current += tmp.U16;
1171   3                  if (--accum_motor_current_count == 0)
1172   3                  {
1173   4                      tmp.U16 = accum_motor_current >> CURRENT_SHIFT_ACC;
1174   4                      average_motor_current_adc = tmp.U16 >> (ADC_RESOLUTION-8);
1175   4                      accum_motor_current = 0;
1176   4                      accum_motor_current_count = CURRENT_ACC;
1177   4      
1178   4                      //current in 0.01A
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 20  

1179   4                      // Only 14bits need for PC side. (2^14 * 0.01A = 163A max value)
1180   4                      SLR_motor_current = (((U32)tmp.U16 * ROUND_DIV((U32)CURRENT_UNIT * \
1181   4                              (U32)ADC_REF_VOLTAGE*2UL*(1 << (16-ADC_RESOLUTION)), \
1182   4                                      (U32)(OP_AMP_GAIN*LOAD_RESISTOR)))>>16) & 0x3fff;
1183   4                  }
1184   3              }
1185   2          }
1186   1      
1187   1      #ifdef FEATURE_MEAS_VMDC
1188   1          if( adc_flags & (0x01<<ADC_MUX_VMOTOR) )
1189   1          {
1190   2              // get latest saved value in the array
1191   2              tmp.U16 = adc_result[ADC_MUX_VMOTOR];
1192   2      
1193   2              // unit is 0.01 Volts (10mV)
1194   2              SLR_motor_voltage = ( (U32)tmp.U16 * ROUND_DIV(VMOTOR_DIVIDER_R1_PLUS_R2 * 2UL \
1195   2                      * ADC_REF_VOLTAGE * (1 << (16-ADC_RESOLUTION)), \
1196   2                      10UL*VMOTOR_DIVIDER_R1)) >> 16;
1197   2          }
1198   1      #endif
1199   1      }
1200          
1201          //-----------------------------------------------------------------------------
1202          // MTR_process_adc
1203          //-----------------------------------------------------------------------------
1204          //
1205          // Return Value : None
1206          // Parameters   : None
1207          // Description: Handle motor error events and timing
1208          //
1209          //-----------------------------------------------------------------------------
1210          static void MTR_process_errors(void)
1211          {
1212   1          static U8 oc_count;
1213   1          U16 gap;
1214   1          U16 delta_I;
1215   1          U16 rpm_changes,i_changes;
1216   1      
1217   1          if (SLR_motor_stalled && !last_motor_stalled)
1218   1          {
1219   2              last_motor_stalled = 1;
1220   2              error_event_time = SL_MTR_time();
1221   2              // signal for error condition
1222   2              CLR_FG();
1223   2          }
1224   1      
1225   1          if (SLR_motor_stalled)
1226   1          {
1227   2              gap = SL_MTR_time() - error_event_time;
1228   2              if (gap > ERROR_EVENT_EXPIRE_TIME)
1229   2              {
1230   3                  last_motor_stalled = 0;
1231   3                  SLR_motor_stalled = 0;
1232   3                  SET_FG();
1233   3              }
1234   2              return;
1235   2          }
1236   1      
1237   1          if ( adc_flags & (0x01<<ADC_MUX_CURRENT) )
1238   1          {
1239   2      #ifdef FEATURE_OVERCURRENT
1240   2              if( SLW_oc_debounce && SLW_current_limit)
1241   2              {
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 21  

1242   3                  if ( (MOTOR_RUNNING == SLR_motor_state) && \
1243   3                          ( average_motor_current_adc >= SLW_current_limit) )
1244   3                  {
1245   4                      oc_count++;
1246   4                      if (oc_count >= SLW_oc_debounce)
1247   4                      {
1248   5                          handle_motor_error = 1;
1249   5                      }
1250   4                  }
1251   3                  else
1252   3                  {
1253   4                      oc_count = 0;
1254   4                  }
1255   3              }
1256   2      #endif
1257   2      
1258   2      #ifdef FEATURE_RPM_STALL_DETECTION
1259   2              if(--stall_check_count == 0)
1260   2              {
1261   3                  // Just check when I(current) was increased and target speed is
1262   3                  // higher than current speed because load causes decreasing speed.
1263   3                  // if (Const + (target_speed+Vnew)/2 - Vold) < (k*dI) then, motor is stalled.
1264   3                  if( (SLR_motor_current > prev_I) && (SLW_target_rpm > SLR_motor_current_rpm))
1265   3                  {
1266   4                      delta_I = SLR_motor_current - prev_I;
1267   4      #if COMPENSATION_CONSTANT_FACTOR == 0
                              rpm_changes = ((SLW_target_rpm + SLR_motor_current_rpm)>>1);
              #else
1270   4                      rpm_changes = ((U32)COMPENSATION_CONSTANT_FACTOR * SLW_motor_max_rpm) >> 16;
1271   4                      rpm_changes += ((SLW_target_rpm + SLR_motor_current_rpm)>>1);
1272   4      #endif
1273   4                      rpm_changes = (rpm_changes - prev_rpm);
1274   4                      i_changes = ((U32)DELTA_CURRENT_FACTOR_K * SLW_motor_max_rpm * delta_I) >> 16;
1275   4                      // (C + Vnew - Vold) < k*dI ?
1276   4                      if( rpm_changes < i_changes)
1277   4                      {
1278   5                          handle_motor_error = 1;
1279   5                      }
1280   4                  }
1281   3                  stall_check_count = STALL_CHECK_COUNT;
1282   3                  prev_rpm = SLR_motor_current_rpm;
1283   3                  prev_I = SLR_motor_current;
1284   3              }
1285   2      #endif
1286   2          }
1287   1      
1288   1          if (handle_motor_error)
1289   1          {
1290   2              SL_MTR_stop_motor();
1291   2              SLR_motor_stalled = 1;
1292   2              handle_motor_error = 0;
1293   2          }
1294   1      
1295   1      }
1296          
1297          
1298          //-----------------------------------------------------------------------------
1299          // CMP1_ISR
1300          //-----------------------------------------------------------------------------
1301          //
1302          // CMP1 ISR Content goes here. Remember to clear flag bits:
1303          // CMP1CN0::CPFIF (Comparator Falling-Edge Flag)
1304          // CMP1CN0::CPRIF (Comparator Rising-Edge Flag)
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 22  

1305          //
1306          //-----------------------------------------------------------------------------
1307          SI_INTERRUPT (CMP1_ISR, CMP1_IRQn)
1308          {
1309   1              static UU32 ticks;
1310   1      
1311   1                  // below code takes about 25us
1312   1                  MTR_save_zero_crossing_time();
1313   1                  ticks.U32 = zc_time.U32 - prev_zc_time.U32;
1314   1      
1315   1                  //Exponential filter
1316   1                  zc_commutate_time.U32 = (zc_commutate_time.U32>>1) +
1317   1                          ((zc_commutate_time.U32+ticks.U32)>>2);
1318   1      
1319   1                  // for rpm calculation
1320   1                  time_per_rotate.U32 += zc_commutate_time.U32;
1321   1                  if(--zc_count == 0)
1322   1                  {
1323   2                      zc_total_per_mech_rotation = time_per_rotate.U32;
1324   2                      time_per_rotate.U32 = 0UL;
1325   2                      zc_count = zc_total_count;
1326   2                      speed_updated = 1;
1327   2                  }
1328   1      
1329   1                  // time to next commutation.
1330   1                  ticks.U32 = (zc_commutate_time.U32 >> 1);
1331   1                  if (ticks.U32 > (PHASE_ADVANCE+4))
1332   1                  {
1333   2                      ticks.U32 -= PHASE_ADVANCE;
1334   2                  }
1335   1                  else
1336   1                  {
1337   2                      ticks.U32 = 4;
1338   2                  }
1339   1      
1340   1                  // expected next commutation time
1341   1                  repeated_timer0 = 0;
1342   1                  timer0_next.U16 = ticks.U16[LSB];
1343   1                  TCON &= ~0x30;
1344   1              #ifdef FEATURE_HYPERDRIVE
                          if (hyperdrive_speed)
                          {
              
                              // additional phase advance = (hrem_time * (hyperdrive_speed/256));
                              // max(hyperdrive_speed) == 255
                              hrem_time = (ticks.U16[LSB] >> HYPER_CMT_SHIFT);
                              ticks.U16[MSB] = (U16)(hrem_time >> 8) * hyperdrive_speed;
                              ticks.U16[MSB] += ((U16)(hrem_time & 0xff) * hyperdrive_speed) >> 8;
                              ticks.U16[LSB] += ticks.U16[MSB];
              
                              timer0_next.U16 = ticks.U16[LSB];
              
                              //Re-use MSB of ticks
                              ticks.UU16[MSB].U8[MSB] = 255 - hyperdrive_speed;
              
                              if (ticks.UU16[MSB].U8[MSB])
                              {
                                  // hrem_time = (high(ticks.U16[LSB])*(255-hyperdrive_speed))>>8
                                  hrem_time = (U16)ticks.UU16[LSB].U8[MSB] * ticks.UU16[MSB].U8[MSB];
                                  hrem_time += ((U16)ticks.UU16[LSB].U8[LSB] * ticks.UU16[MSB].U8[MSB]) >> 8;
                                  ticks.U16[LSB] = hrem_time;
              
                              }
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 23  

                              else
                              {
                                  // We should not energize the 3rd terminal immediately
                                  // here as it would trigger a sudden surge in current
                                  // best to go through timer interrupt to have a more
                                  // gradual increase in current
                                  ticks.U16[LSB] = 1;
              
                              }
                              // hrem_time = (timer0_next + timer0_next*x) * y; (x < 1.0, y < 1.0)
                              // x --> additional phase advance factor
                              hrem_time = timer0_next.U16 - ticks.U16[LSB];
                              timer0_state = TIMER0_START_HYPERDRIVE;
              
                              timer0_next.U16 >>= 1;  // Half the remaining time for skipping inductive kick
                          }
                          else
                      #endif
1386   1                  {
1387   2                      timer0_state = TIMER0_COMMUTATION;
1388   2                  }
1389   1                  ticks.U16[LSB] = -ticks.U16[LSB];
1390   1      
1391   1                  TL0 = ticks.UU16[LSB].U8[LSB];
1392   1                  TH0 = ticks.UU16[LSB].U8[MSB];
1393   1                  TCON_TR0 = 1;
1394   1      
1395   1                  //disable comparator interrupt
1396   1                  CMP1MD = 0x00;
1397   1                  CMP1CN0 &= ~0x30;
1398   1      
1399   1              #ifdef FEATURE_FG
                          if ((commutation_index == 0) || (commutation_index == 3))
                          {
                              TOGGLE_FG();
                          }
                      #endif
1405   1      
1406   1                  // pre_calculation to minimize overhead in timer 0 commutation time.
1407   1                  MTR_pre_commutation();
1408   1      
1409   1                  SET_CPT0_NORMAL_PRIORITY();
1410   1                  // This must be last - otherwise, timer interrupt may be executed prematurely.
1411   1                  SET_TIMER0_HIGH_PRIORITY();
1412   1      }
1413          
1414          
1415          //-----------------------------------------------------------------------------
1416          // TIMER0_ISR
1417          //-----------------------------------------------------------------------------
1418          //
1419          // TIMER0 ISR Content goes here. Remember to clear flag bits:
1420          // TCON::TF0 (Timer 0 Overflow Flag)
1421          //
1422          //-----------------------------------------------------------------------------
1423          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
1424          {
1425   1          static UU16 hyt;
1426   1          TCON_TF0 = 0;
1427   1      
1428   1      here:
1429   1          // to avoid any overhead, do critical one first.
1430   1          if ( TIMER0_COMMUTATION == timer0_state )
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 24  

1431   1          {
1432   2              if( 0 == repeated_timer0 )// it takes about 8 us
1433   2              {
1434   3                  MTR_commutate();
1435   3      
1436   3                  // Make filtered pins digital - to enable blanking signal
1437   3                  P0MDIN |= FILTERED_ALLPINS_MASK;
1438   3      
1439   3                  rising_bemf = ~rising_bemf;
1440   3                  if(rising_bemf)
1441   3                  {
1442   4                      CMP1MX = compMux[open_phase + 6];
1443   4                  }
1444   3                  else
1445   3                  {
1446   4                      CMP1MX = compMux[open_phase];
1447   4                  }
1448   3                  repeated_timer0 = 0;
1449   3                  // 12.5% (7.5deg)
1450   3                  timer0_next.U16 = -(timer0_next.U16>>2);
1451   3                  TCON &= ~0x30;
1452   3                  TL0 = timer0_next.U8[LSB];
1453   3                  TH0 = timer0_next.U8[MSB];
1454   3                  TCON_TR0 = 1;
1455   3                  timer0_state = TIMER0_SKIP_INDUCTIVE_KICK;
1456   3                  SET_TIMER0_HIGH_PRIORITY();
1457   3                  SET_CPT0_NORMAL_PRIORITY();
1458   3                  //disable comparator interrupt
1459   3                  CMP1CN0 &= ~0x30;
1460   3                  CMP1CN0 &= ~0x30;
1461   3              }
1462   2              else
1463   2              {
1464   3                  repeated_timer0--;
1465   3                  TCON &= ~0x30;
1466   3                  TL0 = timer0_next.U8[LSB];
1467   3                  TH0 = timer0_next.U8[MSB];
1468   3                  TCON_TR0 = 1;
1469   3              }
1470   2          }
1471   1      #ifdef FEATURE_HYPERDRIVE
                  else if ( TIMER0_START_HYPERDRIVE == timer0_state )
                  {
                      // Hyperdrive mode
                      timer0_state = TIMER0_COMMUTATION;
                      TCON &= ~0x30;
                      hyt.U8[LSB] = TL0;
                      hyt.U8[MSB] = TH0;
                      if (hyt.U16 >= hrem_time)
                      {
                          goto here;
                      }
                      hyt.U16 -= hrem_time;
                      TL0 = hyt.U8[LSB];
                      TH0 = hyt.U8[MSB];
                      TR0 = 1;
                      MTR_hyper_commutate();
                  }
              #endif
1490   1          else if ( TIMER0_SKIP_INDUCTIVE_KICK == timer0_state )
1491   1          {
1492   2              // enable comparator interrupt
1493   2              // falling edge detection for ZC
C51 COMPILER V9.53.0.0   MOTOR                                                             01/21/2020 10:02:11 PAGE 25  

1494   2              CMP1CN0 &= ~0x30;
1495   2              CMP1MD = 0x00;
1496   2              CMP1MD = 0x10;
1497   2      
1498   2              // waiting for zero crossing...
1499   2              // comparator interrupt will detect zero-crossing event.
1500   2              repeated_timer0 = 0xFF;
1501   2              TCON &= ~0x30;
1502   2              TL0 = 0;
1503   2              TH0 = 0;
1504   2              TCON_TR0 = 1;
1505   2              timer0_state = TIMER0_ZERO_DETECTING;
1506   2              SET_TIMER0_NORMAL_PRIORITY();
1507   2              SET_CPT0_HIGH_PRIORITY();
1508   2          }
1509   1          else if ( TIMER0_ZERO_DETECTING == timer0_state )
1510   1          {
1511   2              repeated_timer0--;
1512   2              // Could not detect zero crossing long time.
1513   2              // Stall
1514   2              if (repeated_timer0 < 0xF0)
1515   2              {
1516   3                  handle_motor_error = 1;
1517   3              }
1518   2          }
1519   1      }
*** WARNING C280 IN LINE 1425 OF C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\motor.c: 'hyt': unr
             -eferenced local variable
*** WARNING C280 IN LINE 1428 OF C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\motor.c: 'here': un
             -referenced label
1520          
*** WARNING C316 IN LINE 1520 OF C:\Users\A92862\SimplicityStudio\v4_workspace\EFM8BB1_BLDC_PORT\src\motor.c: unterminat
             -ed conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2619    ----
   CONSTANT SIZE    =     42    ----
   XDATA SIZE       =     39      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35      13
   IDATA SIZE       =      1    ----
   BIT SIZE         =     11       8
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
